---
phase: 05-full-autonomy-and-permissions
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - skill/src/connection-store.ts
  - skill/src/connection-store.test.ts
  - skill/src/inbound-router.ts
  - skill/src/inbound-router.test.ts
  - skill/src/autonomy/activity-feed.ts
  - skill/src/autonomy/activity-feed.test.ts
  - skill/src/tools/pinch-autonomy.ts
  - skill/src/tools/pinch-autonomy.test.ts
  - skill/src/index.ts
  - skill/package.json
autonomous: true
requirements: [AUTO-03, AUTO-04, AUTO-06, AUTO-07]

must_haves:
  truths:
    - "Full Manual queues every inbound message for human approval with no TTL"
    - "Notify processes messages autonomously and creates activity feed entry with processed_autonomously badge"
    - "Full Auto processes messages independently and logs to audit trail"
    - "Human can change autonomy level for any connection at any time via pinch-autonomy tool"
    - "Autonomy level changes take effect immediately for the next inbound message"
    - "Agent is NOT notified of peer's autonomy level changes"
  artifacts:
    - path: "skill/src/connection-store.ts"
      provides: "Extended AutonomyLevel type with 4 tiers, autoRespondPolicy field on Connection"
      contains: "full_manual.*notify.*auto_respond.*full_auto"
    - path: "skill/src/inbound-router.ts"
      provides: "4-tier routing with notify and auto_respond branches"
      contains: "case.*notify"
    - path: "skill/src/autonomy/activity-feed.ts"
      provides: "ActivityFeed class recording processed_autonomously events"
      exports: ["ActivityFeed"]
    - path: "skill/src/tools/pinch-autonomy.ts"
      provides: "CLI tool for setting autonomy level"
      contains: "pinch-autonomy"
  key_links:
    - from: "skill/src/inbound-router.ts"
      to: "skill/src/autonomy/activity-feed.ts"
      via: "ActivityFeed.record() called in notify branch"
      pattern: "activityFeed\\.record"
    - from: "skill/src/tools/pinch-autonomy.ts"
      to: "skill/src/connection-store.ts"
      via: "setAutonomy() call"
      pattern: "connectionStore\\.setAutonomy"
---

<objective>
Extend the 2-state autonomy system (Full Manual / Full Auto) to 4 tiers (Full Manual / Notify / Auto-respond / Full Auto) with InboundRouter routing for each tier, an activity feed for Notify events, and a pinch-autonomy CLI tool for changing autonomy levels.

Purpose: This is the foundation for Phase 5 -- the autonomy types and routing branches that all other plans depend on. Without the 4-tier type system and routing, permissions and circuit breakers have nowhere to plug in.

Output: Extended AutonomyLevel type, 4-branch InboundRouter, ActivityFeed class, pinch-autonomy tool, updated tests.
</objective>

<execution_context>
@/Users/riecekeck/.claude/get-shit-done/workflows/execute-plan.md
@/Users/riecekeck/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@skill/src/connection-store.ts
@skill/src/inbound-router.ts
@skill/src/message-store.ts
@skill/src/tools/cli.ts
@skill/src/tools/pinch-send.ts
@skill/src/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend AutonomyLevel to 4 tiers and add ActivityFeed</name>
  <files>
    skill/src/connection-store.ts
    skill/src/connection-store.test.ts
    skill/src/autonomy/activity-feed.ts
    skill/src/autonomy/activity-feed.test.ts
  </files>
  <action>
**connection-store.ts changes:**

1. Extend `AutonomyLevel` type from `"full_manual" | "full_auto"` to `"full_manual" | "notify" | "auto_respond" | "full_auto"`.

2. Add `autoRespondPolicy?: string` field to the `Connection` interface. This stores the human-written natural language policy for Auto-respond evaluation. It is a free-text string (potentially multi-line). Only meaningful when `autonomyLevel === "auto_respond"`.

3. Add `circuitBreakerTripped?: boolean` field to the `Connection` interface. This persists across restarts so a circuit-broken connection stays at Full Manual until the human explicitly re-upgrades. Default undefined/false.

4. Update `updateConnection()` to allow updating `autoRespondPolicy` and `circuitBreakerTripped` in the `Pick` type.

5. Update `setAutonomy()`:
   - Per locked decision: "Human can set any autonomy level at any time, including Full Auto on a brand-new connection."
   - The confirmation gate should apply ONLY when upgrading TO `full_auto` from any other level (not just from `full_manual`).
   - When setting autonomy, clear `circuitBreakerTripped` flag if it was set (human is manually overriding).
   - Allow all other transitions without confirmation.

**connection-store.test.ts changes:**
- Add tests for the 4-tier autonomy values: setting notify, auto_respond, upgrading from notify to full_auto (requires confirmed), downgrading from full_auto to notify (no confirmation needed).
- Test that `autoRespondPolicy` is stored and retrieved.
- Test that `circuitBreakerTripped` is cleared on `setAutonomy()`.

**autonomy/activity-feed.ts (NEW):**

Create an `ActivityFeed` class backed by the existing MessageStore's SQLite database. It uses the same `better-sqlite3` Database instance (passed in constructor).

```typescript
interface ActivityEvent {
  id: string;          // UUIDv7
  connectionAddress: string;
  eventType: string;   // 'message_processed_autonomously', 'circuit_breaker_tripped', 'autonomy_changed'
  messageId?: string;
  badge?: string;      // 'processed_autonomously', 'circuit_breaker'
  details?: string;    // JSON blob for event-specific data
  createdAt: string;   // ISO timestamp
}
```

Methods:
- `constructor(db: DatabaseType)` - Takes existing better-sqlite3 Database instance. Creates `activity_events` table if not exists with indexes on `(connection_address, created_at)` and `(event_type, created_at)`.
- `record(event: Omit<ActivityEvent, 'id' | 'createdAt'>): ActivityEvent` - Records an event, generates UUIDv7 id and ISO timestamp.
- `getEvents(opts: { connectionAddress?: string; eventType?: string; limit?: number }): ActivityEvent[]` - Query events with optional filters. Returns DESC by createdAt.

Use `uuid` package (already in project) for UUIDv7 generation via `v7()`.

**autonomy/activity-feed.test.ts (NEW):**
- Test table creation (activity_events table exists after construction).
- Test record and retrieval by connectionAddress.
- Test record and retrieval by eventType.
- Test getEvents with limit.
- Test UUIDv7 ordering (later events have higher IDs).
  </action>
  <verify>
    <automated>cd /Users/riecekeck/Coding/Pinch && npx vitest run skill/src/connection-store.test.ts skill/src/autonomy/activity-feed.test.ts --reporter=verbose 2>&1 | tail -30</automated>
    <manual>Verify AutonomyLevel type includes all 4 values</manual>
  </verify>
  <done>AutonomyLevel has 4 tiers, Connection has autoRespondPolicy and circuitBreakerTripped fields, setAutonomy allows all transitions with confirmation gate only for full_auto upgrade, ActivityFeed records and queries events with SQLite persistence. All tests pass.</done>
</task>

<task type="auto">
  <name>Task 2: Extend InboundRouter to 4-tier routing and create pinch-autonomy tool</name>
  <files>
    skill/src/inbound-router.ts
    skill/src/inbound-router.test.ts
    skill/src/tools/pinch-autonomy.ts
    skill/src/tools/pinch-autonomy.test.ts
    skill/src/index.ts
    skill/package.json
  </files>
  <action>
**inbound-router.ts changes:**

1. Add `ActivityFeed` as a constructor dependency (3rd parameter, after connectionStore and messageStore).

2. Update `route()` to handle all 4 autonomy levels via a switch statement. Per locked decisions:
   - `full_manual`: Set state to `"escalated_to_human"`. Queue indefinitely (no TTL, no auto-reject). This is the existing behavior -- no change needed.
   - `notify`: Set state to `"read_by_agent"` (process autonomously). ALSO call `this.activityFeed.record()` with `eventType: 'message_processed_autonomously'`, `badge: 'processed_autonomously'`, the messageId and connectionAddress. The human sees it when they check the feed.
   - `auto_respond`: Set state to `"pending_policy_eval"`. Add the new state to MessageStore (it's just a string column, no schema change needed). The actual LLM evaluation is handled by the PolicyEvaluator (Plan 02) -- for now, just mark the state. Return the routed message with `state: "pending_policy_eval"`.
   - `full_auto`: Set state to `"read_by_agent"`. This is the existing behavior -- no change needed.
   - Default (unknown levels): Set state to `"escalated_to_human"`. This is the existing safety fallback.

3. Add a `getPendingPolicyEval(): MessageRecord[]` method that returns messages in `"pending_policy_eval"` state, ordered ASC (same pattern as `getPendingForReview`). This will be consumed by Plan 02's PolicyEvaluator.

**inbound-router.test.ts changes:**
- Update the constructor call to include a mock ActivityFeed (create a minimal mock with a `record` method that tracks calls).
- Add test: notify level routes to `read_by_agent` AND calls activityFeed.record with correct event type and badge.
- Add test: auto_respond level routes to `pending_policy_eval`.
- Add test: getPendingPolicyEval returns only messages in pending_policy_eval state, ASC order.
- Existing full_manual and full_auto tests should still pass (update constructor calls).

**tools/pinch-autonomy.ts (NEW):**

Create following the existing tool pattern (see pinch-send.ts):
- Self-executable TypeScript module with `process.argv[1]` check.
- `parseArgs(args: string[])` exported for testability.
- `run()` function: bootstrap -> parse args -> set autonomy -> JSON output -> shutdown.

CLI interface:
```
pinch-autonomy --address <pinch:address> --level <full_manual|notify|auto_respond|full_auto> [--confirmed] [--policy "natural language policy text"]
```

Arguments:
- `--address` (required): The peer's pinch: address.
- `--level` (required): One of the 4 autonomy levels.
- `--confirmed`: Required flag when upgrading to full_auto. If upgrading to full_auto without --confirmed, output an error message explaining the requirement.
- `--policy` (optional): Natural language policy text for auto_respond. If level is auto_respond and --policy is provided, store it via `connectionStore.updateConnection(address, { autoRespondPolicy: policy })`.

Output JSON: `{ "address": "...", "previous_level": "...", "new_level": "...", "policy": "..." }`

Error JSON: `{ "error": "..." }`

Per locked decision: "Agent can suggest autonomy changes (surfaced in activity feed) but the human must approve. No self-upgrade." -- This is a human-initiated tool, so it's the human using it. The agent cannot call it autonomously. This constraint is enforced by OpenClaw skill design, not by this tool.

**tools/pinch-autonomy.test.ts (NEW):**
- Test parseArgs with all arguments.
- Test parseArgs with missing --address.
- Test parseArgs with missing --level.
- Test parseArgs with invalid --level value.
- Test parseArgs with --policy.

**index.ts changes:**
- Export `ActivityFeed` from `"./autonomy/activity-feed.js"`.
- Export `ActivityEvent` type from `"./autonomy/activity-feed.js"`.

**package.json changes:**
- Add `"pinch-autonomy": "./dist/tools/pinch-autonomy.js"` to the `bin` field.
  </action>
  <verify>
    <automated>cd /Users/riecekeck/Coding/Pinch && npx vitest run skill/src/inbound-router.test.ts skill/src/tools/pinch-autonomy.test.ts --reporter=verbose 2>&1 | tail -30</automated>
    <manual>Check that InboundRouter has 4 branches in the switch statement</manual>
  </verify>
  <done>InboundRouter routes all 4 autonomy levels correctly: full_manual -> escalated_to_human, notify -> read_by_agent + activity feed entry, auto_respond -> pending_policy_eval, full_auto -> read_by_agent. pinch-autonomy tool sets autonomy level with confirmation gate for full_auto. All tests pass.</done>
</task>

</tasks>

<verification>
Run all existing tests to verify no regressions:
```bash
cd /Users/riecekeck/Coding/Pinch && npx vitest run --reporter=verbose 2>&1 | tail -50
```

Verify the AutonomyLevel type has all 4 values:
```bash
grep -n "AutonomyLevel" skill/src/connection-store.ts
```

Verify InboundRouter has all 4 branches:
```bash
grep -n "case.*:" skill/src/inbound-router.ts
```
</verification>

<success_criteria>
- AutonomyLevel type includes "full_manual", "notify", "auto_respond", "full_auto"
- Connection interface has autoRespondPolicy and circuitBreakerTripped fields
- setAutonomy allows all 4 levels with confirmation gate only for full_auto upgrades
- InboundRouter.route() handles all 4 levels with correct state transitions
- Notify branch creates activity feed entry with processed_autonomously badge
- Auto-respond branch sets pending_policy_eval state (async evaluation deferred to Plan 02)
- ActivityFeed persists events in SQLite with queryable indexes
- pinch-autonomy tool sets autonomy level with JSON output
- All new and existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/05-full-autonomy-and-permissions/05-01-SUMMARY.md`
</output>
