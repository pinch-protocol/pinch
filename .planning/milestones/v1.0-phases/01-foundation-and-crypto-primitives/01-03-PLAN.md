---
phase: 01-foundation-and-crypto-primitives
plan: 03
type: execute
wave: 2
depends_on:
  - "01-01"
files_modified:
  - relay/cmd/pinchd/main.go
  - relay/internal/hub/hub.go
  - relay/internal/hub/client.go
  - relay/internal/hub/hub_test.go
  - relay/go.mod
  - relay/go.sum
  - skill/src/relay-client.ts
  - skill/src/relay-client.test.ts
  - skill/package.json
autonomous: true
requirements:
  - RELY-01
  - RELY-03
  - RELY-08

must_haves:
  truths:
    - "Go relay starts an HTTP server, accepts WebSocket upgrades at /ws, and maintains connections"
    - "TypeScript client connects to the relay via WebSocket and stays connected"
    - "Relay sends ping every 25s, client responds with pong, connection stays alive"
    - "When a client disconnects, the relay unregisters it from the routing table with no goroutine leak"
    - "Relay routing table maps pinch: addresses to active WebSocket connections"
    - "Health endpoint returns goroutine count and connection count"
  artifacts:
    - path: "relay/internal/hub/hub.go"
      provides: "Hub goroutine managing routing table, register/unregister channels"
      exports: ["Hub", "NewHub", "Run"]
      min_lines: 50
    - path: "relay/internal/hub/client.go"
      provides: "Client struct with readPump, writePump, heartbeat goroutines"
      exports: ["Client", "NewClient"]
      min_lines: 60
    - path: "relay/cmd/pinchd/main.go"
      provides: "Relay binary entry point with HTTP server and WebSocket handler"
      contains: "websocket.Accept"
    - path: "skill/src/relay-client.ts"
      provides: "TypeScript WebSocket client with heartbeat and reconnection"
      exports: ["RelayClient"]
      min_lines: 40
  key_links:
    - from: "relay/cmd/pinchd/main.go"
      to: "relay/internal/hub/hub.go"
      via: "creates Hub and passes to WebSocket handler"
      pattern: "hub\\.NewHub|hub\\.Run"
    - from: "relay/internal/hub/client.go"
      to: "relay/internal/hub/hub.go"
      via: "client registers/unregisters via hub channels"
      pattern: "hub\\.register|hub\\.unregister"
    - from: "skill/src/relay-client.ts"
      to: "relay/cmd/pinchd/main.go"
      via: "WebSocket connection to /ws endpoint"
      pattern: "ws://.*\\/ws"
---

<objective>
Build the Go relay WebSocket server with hub-and-spoke architecture (routing table, heartbeat, goroutine-safe connection lifecycle) and a TypeScript client that connects and maintains the connection. Verify no goroutine leaks on disconnect.

Purpose: Establish the relay infrastructure that all message routing depends on. The hub pattern with proper context-based lifecycle management prevents the goroutine leak class of bugs identified in PITFALLS.md.
Output: Running relay that accepts WebSocket connections, TypeScript client that connects, heartbeat keeps connections alive, clean disconnect with no leaks.
</objective>

<execution_context>
@/Users/riecekeck/.claude/get-shit-done/workflows/execute-plan.md
@/Users/riecekeck/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-and-crypto-primitives/01-RESEARCH.md
@.planning/phases/01-foundation-and-crypto-primitives/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement Go relay hub with WebSocket, heartbeat, and routing table</name>
  <files>
    relay/internal/hub/hub.go
    relay/internal/hub/client.go
    relay/internal/hub/hub_test.go
    relay/cmd/pinchd/main.go
    relay/go.mod
    relay/go.sum
  </files>
  <action>
    **Install dependencies:**
    - `cd relay && go get github.com/coder/websocket@v1.8.14 github.com/go-chi/chi/v5@v5.2.3`

    **Hub** (`relay/internal/hub/hub.go`):
    - `type Hub struct` with:
      - `clients map[string]*Client` -- routing table: pinch: address -> Client
      - `register chan *Client`
      - `unregister chan *Client`
      - `mu sync.RWMutex` (for external reads of routing table, e.g., health check)
    - `func NewHub() *Hub` -- initialize channels and map
    - `func (h *Hub) Run(ctx context.Context)` -- goroutine loop:
      - select on register, unregister, ctx.Done()
      - register: add client to map by address
      - unregister: remove from map, cancel client context, close client send channel
    - `func (h *Hub) ClientCount() int` -- thread-safe client count for health check
    - `func (h *Hub) LookupClient(address string) (*Client, bool)` -- routing table lookup (for future message routing)

    **Client** (`relay/internal/hub/client.go`):
    - `type Client struct` with:
      - `hub *Hub`
      - `conn *websocket.Conn`
      - `address string` -- the pinch: address (Phase 1: provided by client, NOT yet authenticated)
      - `send chan []byte` -- outbound message channel (buffered, 256)
      - `ctx context.Context`
      - `cancel context.CancelFunc`
    - `func NewClient(hub *Hub, conn *websocket.Conn, address string) *Client`
    - `func (c *Client) ReadPump()`:
      - Loop: `conn.Read(c.ctx)` with 60s read deadline
      - On error: unregister from hub, return
      - For Phase 1: discard received messages (no routing yet), just keep connection alive
    - `func (c *Client) WritePump()`:
      - Loop: select on `c.send` channel and `c.ctx.Done()`
      - Write messages with 10s write deadline via `context.WithTimeout`
      - On ctx.Done: return
    - `func (c *Client) HeartbeatLoop()`:
      - Ticker at 25 seconds (within 20-30s requirement)
      - On tick: `conn.Ping(ctx)` with 7-second timeout (within 5-10s requirement)
      - On ping failure: close connection with StatusPolicyViolation, return
      - On ctx.Done: return

    **Main** (`relay/cmd/pinchd/main.go`):
    - Replace placeholder with real server
    - Create Hub, start `hub.Run(ctx)` in goroutine
    - chi router with:
      - `GET /ws` -- WebSocket upgrade handler:
        - `websocket.Accept(w, r, nil)` to accept upgrade
        - Read address from query parameter `?address=pinch:xxx@host` (temporary; Phase 2 replaces with auth)
        - Create Client, register with hub
        - Start readPump, writePump, heartbeatLoop in goroutines
      - `GET /health` -- return JSON `{"goroutines": N, "connections": N}` using runtime.NumGoroutine() and hub.ClientCount()
    - Listen on `:8080` (configurable via `PINCH_RELAY_PORT` env var, default 8080)
    - Graceful shutdown on SIGINT/SIGTERM: cancel context, wait for goroutines

    Use `log/slog` for structured logging: log connection, disconnection, heartbeat failures.

    **Tests** (`relay/internal/hub/hub_test.go`):
    - TestHubRegisterUnregister: create hub, register mock client, verify in routing table, unregister, verify removed
    - TestHubLookup: register client with address, lookup by address succeeds, lookup unknown address returns false
    - TestClientHeartbeatTimeout: create real WebSocket connection (httptest.NewServer), connect, stop reading pongs, verify client is disconnected after timeout
    - TestGoroutineLeakOnDisconnect: record runtime.NumGoroutine(), connect N clients (e.g., 10), disconnect all abruptly, wait briefly, verify goroutine count returns to within 2 of baseline
    - TestGracefulShutdown: start server, connect clients, cancel server context, verify all clients disconnected

    For WebSocket tests, use `httptest.NewServer` with the chi handler and connect via `websocket.Dial`.
  </action>
  <verify>
    <automated>cd /Users/riecekeck/Coding/Pinch && go test ./relay/internal/hub/... -v -race -count=1</automated>
    <manual>Run relay with `go run ./relay/cmd/pinchd/` and verify /health returns JSON</manual>
  </verify>
  <done>Hub registers/unregisters clients correctly. Routing table maps addresses to connections. Heartbeat pings at 25s with 7s pong timeout. Goroutine count returns to baseline after client disconnect. Health endpoint reports goroutine and connection counts.</done>
</task>

<task type="auto">
  <name>Task 2: Implement TypeScript relay client with heartbeat and connection tests</name>
  <files>
    skill/src/relay-client.ts
    skill/src/relay-client.test.ts
    skill/package.json
  </files>
  <action>
    **Install dependencies:**
    - `cd skill && pnpm add ws@8` (should already have @types/ws from Plan 01)

    **RelayClient** (`skill/src/relay-client.ts`):
    - `class RelayClient` with:
      - Constructor: `(relayUrl: string, address: string, options?: { heartbeatInterval?: number })`
      - `connect(): Promise<void>` -- create WebSocket connection to `${relayUrl}/ws?address=${address}`
      - `disconnect(): void` -- clean close, clear heartbeat interval
      - `isConnected(): boolean` -- check readyState === OPEN
      - `onMessage(handler: (data: Buffer) => void): void` -- register message handler
      - Private `startHeartbeat()`: setInterval at 25s, `ws.ping()`, track last pong time, if no pong within 7s of last ping consider connection dead
      - Event handling: `ws.on('pong', ...)` to track alive status, `ws.on('close', ...)` to clean up, `ws.on('error', ...)` to log
      - `waitForConnection(): Promise<void>` -- utility that resolves when WebSocket is open (for tests)
    - Export the class

    Do NOT implement reconnection with exponential backoff yet -- that is not a Phase 1 requirement. Keep the client simple: connect, heartbeat, disconnect.

    **Tests** (`skill/src/relay-client.test.ts`):

    These tests need a running Go relay. Use a test setup that:
    1. Spawns the Go relay as a child process (`go run ./relay/cmd/pinchd/`) on a random port
    2. Waits for it to be ready (poll /health endpoint)
    3. Runs tests against it
    4. Kills the relay process in afterAll

    Test cases:
    - TestConnect: create RelayClient, connect, verify isConnected() is true, verify relay /health shows 1 connection
    - TestDisconnect: connect, disconnect, verify isConnected() is false, verify relay /health shows 0 connections
    - TestMultipleClients: connect 3 clients with different addresses, verify /health shows 3 connections, disconnect all
    - TestHeartbeat: connect client, wait for at least one ping/pong cycle (mock timer or wait 26s -- prefer shorter test with reduced heartbeat interval via constructor option), verify connection stays alive
    - TestServerRejectsInvalidUpgrade: attempt HTTP GET to /ws without WebSocket upgrade headers, verify 4xx response

    **Alternative approach if spawning Go process is complex:** Use a lightweight mock WebSocket server in TypeScript for unit tests (e.g., `ws` can also act as a server). The real integration test against the Go relay can be deferred to the cross-language CI step. If using a mock server, still test the client's heartbeat response behavior.

    Prefer the real Go relay approach if feasible -- it validates the actual WebSocket interop. Set PINCH_RELAY_PORT to a random available port for test isolation.
  </action>
  <verify>
    <automated>cd /Users/riecekeck/Coding/Pinch && pnpm -C skill test -- --reporter=verbose</automated>
    <manual>Start relay manually, run TypeScript client, observe connection in relay /health output</manual>
  </verify>
  <done>TypeScript RelayClient connects to Go relay via WebSocket. Heartbeat ping/pong keeps connection alive. Disconnect cleanly removes client from relay routing table. Multiple clients can connect simultaneously with different addresses.</done>
</task>

</tasks>

<verification>
1. `go test ./relay/internal/hub/... -v -race` -- all hub tests pass, no race conditions
2. `go run ./relay/cmd/pinchd/` starts and serves on :8080
3. `curl localhost:8080/health` returns `{"goroutines": N, "connections": 0}`
4. `pnpm -C skill test` -- relay client tests pass
5. Goroutine leak test: connect 10 clients, disconnect abruptly, goroutine count returns to baseline
6. Heartbeat test: connection survives beyond 25s with active heartbeat
</verification>

<success_criteria>
- Go relay accepts WebSocket connections and maintains a routing table of pinch: addresses
- Heartbeat keeps connections alive with 25s ping / 7s pong timeout
- No goroutine leaks on abrupt disconnect (verified by test)
- TypeScript client connects, stays connected, disconnects cleanly
- Health endpoint reports live goroutine and connection counts
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-and-crypto-primitives/01-03-SUMMARY.md`
</output>
