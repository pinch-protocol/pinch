---
phase: 06-oversight-and-safety
plan: 03
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - skill/src/connection-store.ts
  - skill/src/autonomy/enforcement-pipeline.ts
  - skill/src/autonomy/enforcement-pipeline.test.ts
  - skill/src/message-manager.ts
  - skill/src/tools/pinch-intervene.ts
  - skill/src/tools/pinch-intervene.test.ts
  - skill/src/tools/pinch-mute.ts
  - skill/src/tools/pinch-mute.test.ts
  - skill/src/tools/cli.ts
autonomous: true
requirements:
  - OVRS-03
  - OVRS-04
  - CONN-05

must_haves:
  truths:
    - "Human can enter passthrough mode for a connection and send messages with human attribution"
    - "Human can hand back control to the agent (exit passthrough mode)"
    - "Passthrough flags are cleared on bootstrap to prevent stuck passthrough after disconnect"
    - "Messages carry agent-sent or human-sent attribution visible to the receiving side"
    - "Agent can mute a connection -- messages still delivered (confirmations sent) but not surfaced to agent or human"
    - "Muted messages are recorded in the audit log but not in the activity feed"
    - "Sender has no indication they have been muted"
  artifacts:
    - path: "skill/src/tools/pinch-intervene.ts"
      provides: "CLI tool for entering/exiting passthrough mode and sending human-attributed messages"
      exports: ["parseArgs", "run"]
    - path: "skill/src/tools/pinch-mute.ts"
      provides: "CLI tool for muting/unmuting a connection"
      exports: ["parseArgs", "run"]
    - path: "skill/src/connection-store.ts"
      provides: "Connection interface with muted and passthrough fields"
      contains: "muted"
  key_links:
    - from: "skill/src/autonomy/enforcement-pipeline.ts"
      to: "skill/src/connection-store.ts"
      via: "muted check before circuit breaker"
      pattern: "connection\\.muted"
    - from: "skill/src/tools/pinch-intervene.ts"
      to: "skill/src/connection-store.ts"
      via: "updateConnection passthrough flag"
      pattern: "passthrough"
    - from: "skill/src/message-manager.ts"
      to: "PlaintextPayload content"
      via: "Structured JSON wrapper with attribution field"
      pattern: "application/x-pinch\\+json"
---

<objective>
Add human intervention (passthrough mode), message attribution, and connection muting to the Pinch skill.

Purpose: Gives humans direct control over conversations (OVRS-03, OVRS-04) and the ability to silently mute noisy connections (CONN-05). These are core oversight capabilities that enable the human to step in when needed and filter out unwanted communication.

Output: `pinch-intervene` and `pinch-mute` CLI tools, evolved Connection interface, updated enforcement pipeline with mute filtering, message attribution in outbound messages.
</objective>

<execution_context>
@/Users/riecekeck/.claude/get-shit-done/workflows/execute-plan.md
@/Users/riecekeck/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-oversight-and-safety/06-CONTEXT.md
@.planning/phases/06-oversight-and-safety/06-RESEARCH.md
@.planning/phases/06-oversight-and-safety/06-01-SUMMARY.md
@skill/src/connection-store.ts
@skill/src/autonomy/enforcement-pipeline.ts
@skill/src/autonomy/enforcement-pipeline.test.ts
@skill/src/message-manager.ts
@skill/src/tools/cli.ts
@skill/src/tools/pinch-send.ts
@skill/src/inbound-router.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add muted and passthrough fields to Connection, implement mute in enforcement pipeline</name>
  <files>
    skill/src/connection-store.ts
    skill/src/autonomy/enforcement-pipeline.ts
    skill/src/autonomy/enforcement-pipeline.test.ts
    skill/src/tools/cli.ts
  </files>
  <action>
**Step 1: Extend Connection interface** in `skill/src/connection-store.ts`:

Add two optional fields to the `Connection` interface:
```typescript
/** Whether the connection is muted. Muted messages are delivered (confirmations sent) but not surfaced. */
muted?: boolean;
/** Whether the human is in passthrough mode for this connection. */
passthrough?: boolean;
```

Add `muted` and `passthrough` to the `updateConnection` method's `Pick<>` type union so they can be updated.

**Step 1b: Clear passthrough flags on bootstrap** (Pitfall 3 safeguard â€” passthrough stuck after disconnect):

In `skill/src/tools/cli.ts`, inside the `bootstrap()` function, after the ConnectionStore is loaded, clear all passthrough flags:
```typescript
// Safety: clear any stuck passthrough flags from previous session
// If the CLI disconnected while passthrough was active, messages would pile up
// in 'escalated_to_human' state indefinitely. Clearing on bootstrap prevents this.
connectionStore.clearPassthroughFlags();
```

Add `clearPassthroughFlags()` method to `ConnectionStore` in `connection-store.ts`:
```typescript
/** Clear all passthrough flags. Called on bootstrap to prevent stuck passthrough after disconnect. */
clearPassthroughFlags(): void {
  for (const conn of this.connections.values()) {
    if (conn.passthrough) {
      conn.passthrough = false;
    }
  }
  this.save();
}
```

**Step 2: Add mute check to enforcement pipeline** in `skill/src/autonomy/enforcement-pipeline.ts`:

In the `process()` method, add a mute check BEFORE step 1 (permissions check) -- per research pitfall 5, muted messages should skip the entire enforcement pipeline to avoid triggering circuit breakers:

```typescript
// Step 0: Mute check (before everything else -- per pitfall 5)
const connection = this.connectionStore.getConnection(connectionAddress);
if (connection?.muted) {
  // Record in audit log (hash-chained) but NOT in activity feed
  this.activityFeed.record({
    connectionAddress,
    eventType: "message_received_muted",
    messageId: message.id,
    actorPubkey: "", // sender pubkey would go here if available
    actionType: "message_receive_muted",
    badge: "muted",
  });
  // Mark as delivered (so delivery confirmation is sent) but don't surface
  this.messageStore.updateState(message.id, "delivered");
  return {
    messageId: message.id,
    senderAddress: connectionAddress,
    body: message.body,
    threadId: message.threadId,
    replyTo: message.replyTo,
    priority: message.priority,
    state: "delivered",
  };
}
```

**Step 3: Add passthrough check to enforcement pipeline:**

After the mute check but before step 1 (permissions), add passthrough routing:

```typescript
// Step 0b: Passthrough check (human intervention mode)
if (connection?.passthrough) {
  this.messageStore.updateState(message.id, "escalated_to_human");
  this.activityFeed.record({
    connectionAddress,
    eventType: "message_during_intervention",
    messageId: message.id,
    actionType: "message_receive_intervention",
    badge: "intervention",
  });
  return {
    messageId: message.id,
    senderAddress: connectionAddress,
    body: message.body,
    threadId: message.threadId,
    replyTo: message.replyTo,
    priority: message.priority,
    state: "escalated_to_human",
  };
}
```

**Step 4: Update enforcement pipeline tests** in `enforcement-pipeline.test.ts`:

Add test cases:
- Test muted connection: message returns state "delivered", activity feed records "message_received_muted" event, permissions/circuit breaker NOT invoked
- Test passthrough connection: message returns state "escalated_to_human", activity feed records "message_during_intervention"
- Test muted + passthrough: mute takes precedence (mute check is first)
- Test `clearPassthroughFlags()`: set passthrough on 2 connections, call clearPassthroughFlags, verify both are false
- Verify existing test cases continue to pass (non-muted, non-passthrough connections routed normally)

Use the existing mock pattern in the test file. Set `muted: true` or `passthrough: true` on the mock connection returned by connectionStore.getConnection.
  </action>
  <verify>
    <automated>cd /Users/riecekeck/Coding/Pinch && npx vitest run skill/src/autonomy/enforcement-pipeline.test.ts</automated>
  </verify>
  <done>Connection interface supports muted and passthrough flags. Enforcement pipeline short-circuits for muted connections (audit log only, no surfacing). Passthrough routes directly to human. Tests verify both paths.</done>
</task>

<task type="auto">
  <name>Task 2: Create pinch_intervene tool with message attribution and pinch_mute tool</name>
  <files>
    skill/src/tools/pinch-intervene.ts
    skill/src/tools/pinch-intervene.test.ts
    skill/src/tools/pinch-mute.ts
    skill/src/tools/pinch-mute.test.ts
    skill/src/message-manager.ts
  </files>
  <action>
**Step 1: Add message attribution to MessageManager** in `skill/src/message-manager.ts`:

Add an optional `attribution` parameter to `SendMessageParams`:
```typescript
export interface SendMessageParams {
  recipient: string;
  body: string;
  threadId?: string;
  replyTo?: string;
  priority?: "low" | "normal" | "urgent";
  attribution?: "agent" | "human";  // NEW: defaults to "agent"
}
```

In `sendMessage()`, when building the `PlaintextPayload`, wrap the content with attribution:

```typescript
// Wrap content with attribution metadata
const attribution = params.attribution ?? "agent";
const wrappedContent = JSON.stringify({
  text: body,
  attribution,
});
const plaintext = create(PlaintextPayloadSchema, {
  version: 1,
  sequence: BigInt(sequence),
  timestamp: BigInt(Date.now()),
  content: new TextEncoder().encode(wrappedContent),
  contentType: "application/x-pinch+json",  // Signal structured content
});
```

**IMPORTANT backward compatibility note:** Receiving agents that don't understand `application/x-pinch+json` will see the raw JSON string as the message body. This is acceptable per the research recommendation -- it's forward-compatible and receivers can parse the wrapper if they understand it.

Update `handleIncomingMessage()` to detect and parse the structured wrapper:
```typescript
// After decoding body from plaintextPayload.content:
let displayBody = body;
let attribution: "agent" | "human" = "agent";
if (plaintextPayload.contentType === "application/x-pinch+json") {
  try {
    const parsed = JSON.parse(body);
    displayBody = parsed.text ?? body;
    attribution = parsed.attribution ?? "agent";
  } catch {
    // Not valid JSON -- use raw body
    displayBody = body;
  }
}
```

Store the `displayBody` as the message body and record the attribution in the activity feed.

**Step 2: Create `skill/src/tools/pinch-intervene.ts`:**

CLI interface:
```
pinch-intervene --start --connection <address>    # Enter passthrough mode
pinch-intervene --stop --connection <address>     # Exit passthrough mode (handback)
pinch-intervene --send --connection <address> --body <text>  # Send human-attributed message
```

Implementation:
- `parseArgs(args)` -- parse `--start`, `--stop`, `--send`, `--connection`, `--body`
- `run(args)`:
  - For `--start`: `connectionStore.updateConnection(addr, { passthrough: true })`, save, record activity feed event "intervention_started", output JSON `{ status: "passthrough_active", connection: addr }`
  - For `--stop`: `connectionStore.updateConnection(addr, { passthrough: false })`, save, record activity feed event "intervention_ended", output JSON `{ status: "passthrough_ended", connection: addr }`
  - For `--send`: call `messageManager.sendMessage({ recipient: addr, body, attribution: "human" })`, output JSON `{ message_id, status: "sent", attribution: "human" }`
- Self-executable entry point pattern

**Step 3: Create `skill/src/tools/pinch-mute.ts`:**

CLI interface:
```
pinch-mute --connection <address>     # Mute a connection
pinch-mute --unmute --connection <address>  # Unmute a connection
```

Implementation:
- `parseArgs(args)` -- parse `--connection`, `--unmute`
- `run(args)`:
  - For mute: `connectionStore.updateConnection(addr, { muted: true })`, save, record activity feed event "connection_muted", output JSON `{ status: "muted", connection: addr }`
  - For unmute: `connectionStore.updateConnection(addr, { muted: false })`, save, record activity feed event "connection_unmuted", output JSON `{ status: "unmuted", connection: addr }`
- Self-executable entry point pattern

**Step 4: Tests:**

`pinch-intervene.test.ts`:
- Test `parseArgs` for `--start --connection addr`
- Test `parseArgs` for `--stop --connection addr`
- Test `parseArgs` for `--send --connection addr --body "hello"`
- Test `parseArgs` throws when `--connection` missing

`pinch-mute.test.ts`:
- Test `parseArgs` for `--connection addr` (mute)
- Test `parseArgs` for `--unmute --connection addr`
- Test `parseArgs` throws when `--connection` missing
  </action>
  <verify>
    <automated>cd /Users/riecekeck/Coding/Pinch && npx vitest run skill/src/tools/pinch-intervene.test.ts skill/src/tools/pinch-mute.test.ts skill/src/tools/pinch-send.test.ts</automated>
  </verify>
  <done>pinch_intervene tool supports --start, --stop, --send with human attribution. pinch_mute tool supports mute/unmute. Messages carry attribution (agent or human) via structured JSON wrapper in PlaintextPayload content. Receiving side detects and parses attribution. Tests pass.</done>
</task>

</tasks>

<verification>
1. Enforcement pipeline mute path: muted messages get "delivered" state, recorded in audit log, not surfaced
2. Enforcement pipeline passthrough path: messages route directly to human
3. Message attribution: outbound messages include agent/human flag in structured content wrapper
4. Incoming messages: attribution parsed from structured content when present
5. pinch_intervene tool handles start/stop/send modes
6. pinch_mute tool handles mute/unmute
7. All existing enforcement pipeline tests pass (no regressions)
</verification>

<success_criteria>
- Human can enter passthrough mode for a connection via pinch_intervene --start
- Human can send messages with human attribution via pinch_intervene --send
- Human can exit passthrough mode via pinch_intervene --stop
- Agent can mute a connection via pinch_mute --connection
- Muted messages deliver (confirmation sent) but are not surfaced
- Muted messages still recorded in audit log
- Sender never learns they are muted
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/06-oversight-and-safety/06-03-SUMMARY.md`
</output>
