---
phase: 03-encrypted-1-1-messaging
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - skill/src/message-store.ts
  - skill/src/message-store.test.ts
  - skill/src/delivery.ts
  - skill/src/delivery.test.ts
  - skill/src/connection.ts
  - skill/src/connection-store.ts
  - skill/package.json
  - pnpm-lock.yaml
autonomous: true
requirements: [CRYP-01, CRYP-05]

must_haves:
  truths:
    - "Messages are persisted in a SQLite database that survives process restarts"
    - "Per-connection sequence numbers are monotonically increasing and atomically incremented"
    - "Delivery confirmation signatures can be created and verified using Ed25519"
    - "Connection request/approve exchange actual Ed25519 public keys (not empty bytes)"
  artifacts:
    - path: "skill/src/message-store.ts"
      provides: "SQLite-backed message persistence with CRUD and pagination"
      exports: ["MessageStore"]
      min_lines: 100
    - path: "skill/src/delivery.ts"
      provides: "Delivery confirmation signing and verification"
      exports: ["signDeliveryConfirmation", "verifyDeliveryConfirmation"]
      min_lines: 30
  key_links:
    - from: "skill/src/message-store.ts"
      to: "better-sqlite3"
      via: "import Database"
      pattern: "better-sqlite3"
    - from: "skill/src/delivery.ts"
      to: "skill/src/crypto.ts"
      via: "import ensureSodiumReady"
      pattern: "crypto_sign_detached"
    - from: "skill/src/connection.ts"
      to: "skill/src/relay-client.ts"
      via: "sendEnvelope with real public key bytes"
      pattern: "keypair.publicKey"
---

<objective>
Install new dependencies (better-sqlite3, uuid), build the SQLite message store for local persistence, create delivery confirmation signing/verification utilities, and fix the public key exchange gap in ConnectionManager.

Purpose: The message store powers pinch_history and delivery state tracking. The delivery module enables E2E signed receipts. The pubkey fix is a Phase 2 gap that encryption requires -- agents must have each other's Ed25519 public keys to derive X25519 encryption keys.
Output: MessageStore class, delivery signing functions, ConnectionManager with real pubkey exchange.
</objective>

<execution_context>
@/Users/riecekeck/.claude/get-shit-done/workflows/execute-plan.md
@/Users/riecekeck/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-encrypted-1-1-messaging/03-RESEARCH.md
@skill/src/crypto.ts
@skill/src/identity.ts
@skill/src/connection.ts
@skill/src/connection-store.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install dependencies, build SQLite message store, and fix pubkey exchange</name>
  <files>skill/package.json, pnpm-lock.yaml, skill/src/message-store.ts, skill/src/message-store.test.ts, skill/src/connection.ts, skill/src/connection-store.ts</files>
  <action>
**Install dependencies:**
```bash
cd skill && pnpm add better-sqlite3 uuid && pnpm add -D @types/better-sqlite3
```

**Create MessageStore (skill/src/message-store.ts):**

SQLite-backed message persistence class. Constructor takes a database file path.

Schema (run on init with IF NOT EXISTS):
```sql
CREATE TABLE messages (
  id TEXT PRIMARY KEY,              -- UUIDv7 message_id
  connection_address TEXT NOT NULL,  -- peer's pinch: address
  direction TEXT NOT NULL CHECK (direction IN ('inbound', 'outbound')),
  body TEXT NOT NULL,                -- plaintext message content
  thread_id TEXT,                    -- optional thread grouping
  reply_to TEXT,                     -- optional parent message_id
  priority TEXT NOT NULL DEFAULT 'normal' CHECK (priority IN ('low', 'normal', 'urgent')),
  sequence INTEGER NOT NULL,         -- monotonic per-connection
  state TEXT NOT NULL,               -- delivery state per locked decision: sent, relayed, delivered, read_by_agent, escalated_to_human, failed
  failure_reason TEXT,               -- populated when state = 'failed'
  created_at TEXT NOT NULL,          -- ISO timestamp
  updated_at TEXT NOT NULL           -- ISO timestamp
);
CREATE INDEX idx_messages_connection ON messages(connection_address, created_at);
CREATE INDEX idx_messages_thread ON messages(thread_id, created_at);
CREATE INDEX idx_messages_state ON messages(state);
CREATE INDEX idx_messages_direction_state ON messages(direction, state);

CREATE TABLE sequences (
  connection_address TEXT PRIMARY KEY,
  next_sequence INTEGER NOT NULL DEFAULT 1
);
```

Enable WAL mode and foreign keys: `db.pragma("journal_mode = WAL")`.

Methods:
- `constructor(dbPath: string)` -- opens DB, creates tables
- `saveMessage(msg: MessageRecord): void` -- INSERT into messages table
- `getMessage(id: string): MessageRecord | undefined` -- SELECT by id
- `updateState(id: string, state: string, failureReason?: string): void` -- UPDATE state and updated_at
- `getHistory(opts: { connectionAddress?: string; threadId?: string; direction?: string; state?: string; limit?: number; offset?: number }): MessageRecord[]` -- paginated query with optional filters, ordered by created_at DESC
- `getPending(direction: 'inbound' | 'outbound'): MessageRecord[]` -- messages with state 'escalated_to_human' or 'sent' (awaiting confirmation)
- `nextSequence(connectionAddress: string): number` -- atomic increment via INSERT OR IGNORE + UPDATE RETURNING (use a prepared statement with a transaction: insert the address if not exists, then increment and return)
- `close(): void` -- close the database

Export `MessageRecord` interface:
```typescript
interface MessageRecord {
  id: string;
  connectionAddress: string;
  direction: 'inbound' | 'outbound';
  body: string;
  threadId?: string;
  replyTo?: string;
  priority: 'low' | 'normal' | 'urgent';
  sequence: number;
  state: string;
  failureReason?: string;
  createdAt: string;
  updatedAt: string;
}
```

**Fix pubkey exchange gap in ConnectionManager (skill/src/connection.ts):**

The ConnectionManager constructor currently takes `(relayClient, connectionStore)`. Add a third parameter: `keypair: Keypair` (import from identity.ts).

In `sendRequest()`:
- Change `senderPublicKey: new Uint8Array(0)` to `senderPublicKey: this.keypair.publicKey`

In `approveRequest()`:
- Change `responderPublicKey: new Uint8Array(0)` to `responderPublicKey: this.keypair.publicKey`

Update ConnectionStore to also support extracting public key from pinch address as fallback. Add a helper method `getPeerPublicKey(peerAddress: string): Uint8Array | null` to ConnectionStore that:
1. Checks if `peerPublicKey` is non-empty in the connection record and returns base64-decoded bytes
2. Falls back to extracting from pinch address using `validateAddress()` from identity.ts (the address embeds the public key in its base58 payload)

Update connection.test.ts mock to pass a keypair. Ensure existing tests still pass.

**Write tests (skill/src/message-store.test.ts):**
Use vitest. Use temp directories for SQLite database files (cleaned up in afterEach).

Tests:
- saveMessage + getMessage roundtrip
- updateState changes state and updated_at
- getHistory returns messages ordered by created_at DESC with pagination (limit/offset)
- getHistory filters by connectionAddress, threadId, direction
- getPending returns only pending messages
- nextSequence returns 1 for first call, increments atomically
- nextSequence is per-connection (different addresses get independent sequences)
- close() succeeds without error
  </action>
  <verify>
    <automated>cd /Users/riecekeck/Coding/Pinch/skill && pnpm exec vitest run src/message-store.test.ts src/connection.test.ts --reporter=verbose 2>&1 | tail -30</automated>
  </verify>
  <done>better-sqlite3 and uuid installed. MessageStore class creates SQLite DB with messages and sequences tables, supports CRUD, pagination, and atomic sequence increment. ConnectionManager sends real Ed25519 public keys in connection request/approve (not empty bytes). ConnectionStore has getPeerPublicKey fallback. All message-store and connection tests pass.</done>
</task>

<task type="auto">
  <name>Task 2: Create delivery confirmation signing and verification module</name>
  <files>skill/src/delivery.ts, skill/src/delivery.test.ts</files>
  <action>
**Create delivery module (skill/src/delivery.ts):**

Two exported async functions:

```typescript
async function signDeliveryConfirmation(
  messageId: Uint8Array,
  timestamp: bigint,
  privateKey: Uint8Array,
): Promise<Uint8Array>
```
- Calls `ensureSodiumReady()` from crypto.ts
- Concatenates `messageId` + `timestamp` (as 8 big-endian bytes) into a single Uint8Array
- Signs with `sodium.crypto_sign_detached(payload, privateKey)`
- Returns the 64-byte detached signature

```typescript
async function verifyDeliveryConfirmation(
  signature: Uint8Array,
  messageId: Uint8Array,
  timestamp: bigint,
  senderPublicKey: Uint8Array,
): Promise<boolean>
```
- Calls `ensureSodiumReady()` from crypto.ts
- Rebuilds the same `messageId || timestamp` payload
- Verifies with `sodium.crypto_sign_verify_detached(signature, payload, senderPublicKey)`
- Returns boolean

Import `ensureSodiumReady` from crypto.ts and sodium from libsodium-wrappers-sumo.

**Write tests (skill/src/delivery.test.ts):**
Use vitest. Import from identity.ts to generate a test keypair.

Tests:
- signDeliveryConfirmation returns 64-byte signature
- verifyDeliveryConfirmation returns true for valid signature
- verifyDeliveryConfirmation returns false for wrong public key
- verifyDeliveryConfirmation returns false for tampered message_id
- verifyDeliveryConfirmation returns false for tampered timestamp
- Round-trip: sign then verify with correct keys succeeds
  </action>
  <verify>
    <automated>cd /Users/riecekeck/Coding/Pinch/skill && pnpm exec vitest run src/delivery.test.ts --reporter=verbose 2>&1 | tail -20</automated>
  </verify>
  <done>signDeliveryConfirmation and verifyDeliveryConfirmation are exported from delivery.ts. Sign produces 64-byte Ed25519 detached signature over (messageId || timestamp). Verify confirms authenticity using sender's Ed25519 public key. All delivery tests pass.</done>
</task>

</tasks>

<verification>
- `cd skill && pnpm exec vitest run` -- all tests pass (message-store, delivery, connection, existing)
- `ls skill/src/message-store.ts skill/src/delivery.ts` -- both files exist
- `grep -q "getPeerPublicKey" skill/src/connection-store.ts` -- fallback method exists
- `grep -q "this.keypair.publicKey" skill/src/connection.ts` -- real keys sent in connection flow
</verification>

<success_criteria>
- MessageStore persists messages in SQLite with all required fields and indexes
- Sequence numbers are atomically incremented per-connection
- Delivery confirmation signatures are cryptographically correct (Ed25519 detached)
- ConnectionManager exchanges real public keys (not empty Uint8Array)
- All existing tests continue to pass alongside new tests
</success_criteria>

<output>
After completion, create `.planning/phases/03-encrypted-1-1-messaging/03-02-SUMMARY.md`
</output>
