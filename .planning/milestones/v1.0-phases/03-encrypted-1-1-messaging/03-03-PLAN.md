---
phase: 03-encrypted-1-1-messaging
plan: 03
type: execute
wave: 2
depends_on: [03-01, 03-02]
files_modified:
  - skill/src/message-manager.ts
  - skill/src/message-manager.test.ts
  - skill/src/inbound-router.ts
  - skill/src/inbound-router.test.ts
  - skill/src/relay-client.ts
  - skill/src/relay-client.test.ts
autonomous: true
requirements: [CRYP-01, CRYP-05, SKIL-04]

must_haves:
  truths:
    - "Agent A can encrypt a message to Agent B using NaCl box and Agent B can decrypt it"
    - "Delivery confirmations are automatically sent on message receipt and verified on arrival"
    - "Inbound messages are routed based on connection autonomy: Full Manual sets state to escalated_to_human, Full Auto sets state to read_by_agent"
    - "RelayClient reconnects automatically with exponential backoff on disconnect"
  artifacts:
    - path: "skill/src/message-manager.ts"
      provides: "Encrypt/decrypt/send/receive/confirm orchestration"
      exports: ["MessageManager"]
      min_lines: 150
    - path: "skill/src/inbound-router.ts"
      provides: "Autonomy-based inbound message routing"
      exports: ["InboundRouter"]
      min_lines: 40
  key_links:
    - from: "skill/src/message-manager.ts"
      to: "skill/src/crypto.ts"
      via: "encrypt/decrypt calls"
      pattern: "encrypt|decrypt"
    - from: "skill/src/message-manager.ts"
      to: "skill/src/message-store.ts"
      via: "saveMessage/updateState"
      pattern: "messageStore"
    - from: "skill/src/message-manager.ts"
      to: "skill/src/delivery.ts"
      via: "signDeliveryConfirmation/verifyDeliveryConfirmation"
      pattern: "signDeliveryConfirmation|verifyDeliveryConfirmation"
    - from: "skill/src/message-manager.ts"
      to: "skill/src/relay-client.ts"
      via: "sendEnvelope for encrypted messages"
      pattern: "sendEnvelope"
    - from: "skill/src/inbound-router.ts"
      to: "skill/src/connection-store.ts"
      via: "autonomyLevel lookup"
      pattern: "autonomyLevel"
---

<objective>
Build the MessageManager that orchestrates encrypt/send/receive/decrypt flows with automatic delivery confirmations, create the InboundRouter for autonomy-based message routing, and add reconnection with exponential backoff to RelayClient.

Purpose: This is the core messaging layer. MessageManager composes existing crypto primitives (Phase 1), message store (Plan 02), delivery signing (Plan 02), and relay transport (Phase 1) into a complete encrypted messaging flow. InboundRouter implements the autonomy routing that differentiates Pinch from a plain messaging system.
Output: MessageManager class, InboundRouter class, RelayClient with reconnection.
</objective>

<execution_context>
@/Users/riecekeck/.claude/get-shit-done/workflows/execute-plan.md
@/Users/riecekeck/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-encrypted-1-1-messaging/03-RESEARCH.md
@.planning/phases/03-encrypted-1-1-messaging/03-01-SUMMARY.md
@.planning/phases/03-encrypted-1-1-messaging/03-02-SUMMARY.md
@skill/src/crypto.ts
@skill/src/relay-client.ts
@skill/src/message-store.ts
@skill/src/delivery.ts
@skill/src/connection-store.ts
@skill/src/connection.ts
@skill/src/identity.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement MessageManager for encrypted message send/receive/confirm</name>
  <files>skill/src/message-manager.ts, skill/src/message-manager.test.ts</files>
  <action>
**Create MessageManager (skill/src/message-manager.ts):**

Central class coordinating all message operations. Constructor takes:
- `relayClient: RelayClient`
- `connectionStore: ConnectionStore`
- `messageStore: MessageStore`
- `keypair: Keypair` (from identity.ts)
- `inboundRouter: InboundRouter` (from inbound-router.ts -- see Task 2)

**Methods:**

`async init(): Promise<void>`
- Calls `ensureSodiumReady()` once

`async sendMessage(params: { recipient: string; body: string; threadId?: string; replyTo?: string; priority?: 'low' | 'normal' | 'urgent' }): Promise<string>`
1. Validate connection is active via connectionStore.getConnection(recipient)
2. Get peer's Ed25519 public key via connectionStore.getPeerPublicKey(recipient) -- throw if not available
3. Generate messageId using `uuidv7()` from uuid package
4. If threadId not provided and replyTo is provided, look up replyTo message and inherit its threadId. If neither, auto-generate threadId = messageId (first message in a new thread).
5. Get next sequence number via messageStore.nextSequence(recipient)
6. Build PlaintextPayload protobuf: version=1, sequence (as bigint), timestamp=BigInt(Date.now()), content=TextEncoder.encode(body), contentType="text/plain"
7. Serialize PlaintextPayload to bytes via toBinary
8. Convert keys: ed25519PrivToX25519(keypair.privateKey), ed25519PubToX25519(peerEd25519Pub)
9. Encrypt with `encrypt(plaintextBytes, recipientX25519Pub, senderX25519Priv)` from crypto.ts
10. Split result: nonce = first 24 bytes, ciphertext = rest
11. Build Envelope with MESSAGE type, fromAddress=relayClient.assignedAddress, toAddress=recipient, messageId as TextEncoder.encode(messageId), timestamp, encrypted payload containing nonce + ciphertext + senderPublicKey (Ed25519, for recipient to derive X25519)
12. Client-side size check: serialized envelope > 60KB? throw Error("message too large") -- conservative limit leaving room for protobuf overhead (relay enforces 64KB)
13. Save outbound message in messageStore with state "sent"
14. Send via relayClient.sendEnvelope(toBinary(EnvelopeSchema, envelope))
15. Return messageId

`async handleIncomingMessage(envelope: Envelope): Promise<void>`
1. Extract EncryptedPayload from envelope (envelope.payload.case === "encrypted")
2. Get sender address from envelope.fromAddress
3. Get sender's Ed25519 public key from encryptedPayload.senderPublicKey
4. Convert keys: ed25519PubToX25519(senderEd25519Pub), ed25519PrivToX25519(keypair.privateKey)
5. Reconstruct sealed message: concat nonce + ciphertext
6. Decrypt with `decrypt(sealed, senderX25519Pub, recipientX25519Priv)` from crypto.ts
7. Deserialize PlaintextPayload from decrypted bytes via fromBinary
8. Extract text body from content field via TextDecoder
9. Derive messageId from envelope.messageId (TextDecoder)
10. Store inbound message in messageStore with connection_address=sender, direction="inbound", body=text, sequence from PlaintextPayload
11. Route via inboundRouter.route(message, connection) -- determines state based on autonomy
12. Send delivery confirmation back to sender (call sendDeliveryConfirmation)

`private async sendDeliveryConfirmation(messageId: string, senderAddress: string): Promise<void>`
1. Sign: signDeliveryConfirmation(TextEncoder.encode(messageId), BigInt(Date.now()), keypair.privateKey)
2. Build DeliveryConfirm payload with messageId bytes, signature, timestamp, state="delivered" (locked state name)
3. Wrap in Envelope with DELIVERY_CONFIRM type, addressed back to sender
4. Send via relayClient.sendEnvelope

`async handleDeliveryConfirmation(envelope: Envelope): Promise<void>`
1. Extract DeliveryConfirm from envelope (envelope.payload.case === "deliveryConfirm")
2. Get messageId from confirm.messageId (TextDecoder)
3. Look up original message in messageStore
4. Get sender's Ed25519 public key from connectionStore.getPeerPublicKey(envelope.fromAddress)
5. Verify signature: verifyDeliveryConfirmation(confirm.signature, confirm.messageId, confirm.timestamp, peerPubKey)
6. If valid: update message state to confirm.state (e.g., "delivered")
7. If invalid: log warning, do not update state

`setupHandlers(): void`
- Register on relayClient.onEnvelope to dispatch MESSAGE and DELIVERY_CONFIRM types
- Important: this must coexist with ConnectionManager's setupHandlers. Since RelayClient currently supports only one onEnvelope handler, refactor to support multiple handlers by changing `envelopeHandler` from a single callback to an array of callbacks (update relay-client.ts). Each call to onEnvelope pushes to the array, and the dispatch loop calls all handlers.

**Update RelayClient to support multiple envelope handlers:**
In relay-client.ts, change `private envelopeHandler: ((envelope: Envelope) => void) | null = null` to `private envelopeHandlers: ((envelope: Envelope) => void)[] = []`. Update onEnvelope to push, and the dispatch in the message handler to iterate all handlers. This is a small but critical change.

**Write tests (skill/src/message-manager.test.ts):**
Use vitest. Create mock RelayClient (track sentEnvelopes), real MessageStore (temp SQLite), real ConnectionStore (temp JSON), real delivery functions. Generate two test keypairs.

Tests:
- sendMessage encrypts and sends envelope via relayClient
- sendMessage returns a UUIDv7 messageId
- sendMessage stores outbound message with state "sent" in messageStore
- sendMessage throws if connection is not active
- sendMessage throws if peer public key is not available
- sendMessage auto-generates threadId from messageId when not provided
- sendMessage inherits threadId from replyTo message
- sendMessage rejects messages exceeding 60KB body
- handleIncomingMessage decrypts and stores inbound message
- handleIncomingMessage sends delivery confirmation back to sender
- handleDeliveryConfirmation verifies signature and updates message state
- handleDeliveryConfirmation rejects forged confirmation (wrong key)
- Multiple onEnvelope handlers coexist (ConnectionManager + MessageManager)
  </action>
  <verify>
    <automated>cd /Users/riecekeck/Coding/Pinch/skill && pnpm exec vitest run src/message-manager.test.ts --reporter=verbose 2>&1 | tail -30</automated>
  </verify>
  <done>MessageManager encrypts outbound messages with NaCl box, decrypts inbound messages, sends/verifies delivery confirmations, stores all messages in SQLite, and routes inbound via InboundRouter. RelayClient supports multiple onEnvelope handlers. All MessageManager tests pass.</done>
</task>

<task type="auto">
  <name>Task 2: Create InboundRouter and add RelayClient reconnection</name>
  <files>skill/src/inbound-router.ts, skill/src/inbound-router.test.ts, skill/src/relay-client.ts, skill/src/relay-client.test.ts</files>
  <action>
**Create InboundRouter (skill/src/inbound-router.ts):**

Routes inbound messages based on connection autonomy level.

Constructor takes:
- `connectionStore: ConnectionStore`
- `messageStore: MessageStore`

Export interface for routed message result:
```typescript
interface RoutedMessage {
  messageId: string;
  senderAddress: string;
  body: string;
  threadId?: string;
  replyTo?: string;
  priority: 'low' | 'normal' | 'urgent';
  state: string; // locked states: 'escalated_to_human' | 'read_by_agent' | 'failed' (see CONTEXT.md)
}
```

`route(message: MessageRecord, connectionAddress: string): RoutedMessage`

**State names follow the locked decision (CONTEXT.md): sent, relayed, delivered, read_by_agent, escalated_to_human, failed.** The "relayed" state is deferred to Phase 4 when the relay can send acks back to senders.

1. Look up connection via connectionStore.getConnection(connectionAddress)
2. If connection not found or not active, set state to "failed" (message from unknown sender, set failureReason)
3. If autonomyLevel === "full_manual":
   - Update message state to "escalated_to_human" via messageStore.updateState
   - Write a pending item entry (just update the messageStore state -- the HEARTBEAT.md integration will read pending items from the store in Plan 04)
4. If autonomyLevel === "full_auto":
   - Update message state to "read_by_agent" via messageStore.updateState
   - Return with state "read_by_agent" (caller presents to agent)
5. Default (future autonomy levels): treat as full_manual (escalated_to_human)

Also export a `getPendingForReview(): MessageRecord[]` method that returns all messages with state "escalated_to_human", ordered by created_at ASC (oldest first). This powers the HEARTBEAT.md checklist.

`approveMessage(messageId: string, action: 'agent_handle' | 'human_respond'): void`
- Update message state from "escalated_to_human" to "read_by_agent" (if action = 'agent_handle') or "delivered" (if action = 'human_respond', human has seen it)
- Return the message so it can be presented to the agent (if action = 'agent_handle') or the human can respond

**Add reconnection with exponential backoff to RelayClient:**

Add to RelayClient:
- Private fields: `baseDelay = 500`, `maxDelay = 30000`, `maxAttempts = 20`, `reconnectAttempt = 0`, `autoReconnect = false`, `onDisconnect: (() => void) | null = null`
- New constructor option: `autoReconnect?: boolean` in RelayClientOptions
- New method `onDisconnect(handler: () => void): void`
- Modify the `close` event handler: if `authState === "done"` (was connected, then disconnected) AND `autoReconnect` is true, trigger reconnect loop
- `private async reconnect(): Promise<void>`:
  1. While attempt < maxAttempts:
    - Calculate delay: `Math.min(baseDelay * 2^attempt + Math.random() * 1000, maxDelay)`
    - Wait delay
    - Try connect()
    - On success: reset attempt counter, return
    - On failure: increment attempt, continue
  2. If all attempts exhausted: emit error event or call onDisconnect handler
- On successful reconnect: re-register all envelope handlers (they're in the array, just need WebSocket to be reconnected)

Important: `connect()` already creates a new WebSocket. The reconnect just calls `connect()` again after delay. The assignedAddress may change (relay re-derives from public key, but since the keypair is the same, the address will be the same).

**Write tests:**

inbound-router.test.ts:
- Full Manual connection routes message to escalated_to_human state
- Full Auto connection routes message to read_by_agent state
- Unknown sender gets failed state with failure reason
- getPendingForReview returns only escalated_to_human messages
- approveMessage with 'agent_handle' transitions from escalated_to_human to read_by_agent
- approveMessage with 'human_respond' transitions from escalated_to_human to delivered

relay-client.test.ts (add to existing):
- Multiple onEnvelope handlers all receive the same envelope
- (Reconnection is hard to unit test -- integration test in Plan 04 will validate)
  </action>
  <verify>
    <automated>cd /Users/riecekeck/Coding/Pinch/skill && pnpm exec vitest run src/inbound-router.test.ts src/relay-client.test.ts --reporter=verbose 2>&1 | tail -30</automated>
  </verify>
  <done>InboundRouter dispatches inbound messages to escalated_to_human (Full Manual) or read_by_agent (Full Auto) based on connection autonomy level, using locked delivery state names. getPendingForReview surfaces escalated_to_human messages for HEARTBEAT.md. 'relayed' state deferred to Phase 4. RelayClient supports auto-reconnection with exponential backoff and jitter. Multiple envelope handlers coexist. All tests pass.</done></invoke>

</task>

</tasks>

<verification>
- `cd skill && pnpm exec vitest run` -- all tests pass including existing ones
- `grep -q "MessageManager" skill/src/message-manager.ts` -- class exists
- `grep -q "InboundRouter" skill/src/inbound-router.ts` -- class exists
- `grep -q "envelopeHandlers" skill/src/relay-client.ts` -- multiple handler support exists
</verification>

<success_criteria>
- Full encrypt/decrypt message roundtrip works: sender encrypts with NaCl box, receiver decrypts
- Delivery confirmations are signed with Ed25519, sent automatically, and verified on receipt
- Full Manual messages are queued with escalated_to_human state (locked decision name)
- Full Auto messages are marked read_by_agent immediately (locked decision name)
- 'relayed' state deferred to Phase 4 when relay can send acks
- RelayClient reconnects with exponential backoff on disconnect
- All tests pass (new and existing)
</success_criteria>

<output>
After completion, create `.planning/phases/03-encrypted-1-1-messaging/03-03-SUMMARY.md`
</output>
