---
phase: 04-store-and-forward
plan: 02
type: execute
wave: 2
depends_on:
  - "04-01"
files_modified:
  - relay/internal/hub/hub.go
  - relay/internal/hub/client.go
  - relay/internal/hub/hub_test.go
  - relay/cmd/pinchd/main.go
  - skill/src/message-manager.ts
  - skill/src/message-manager.test.ts
  - tests/cross-language/store-forward.integration.test.ts
autonomous: true
requirements:
  - RELY-05
  - RELY-06

must_haves:
  truths:
    - "When Agent B is offline, messages from Agent A are persisted in bbolt and survive relay restarts"
    - "When Agent B reconnects, all queued messages are flushed in order before real-time traffic resumes"
    - "Sender receives delivery confirmation with was_stored=true for messages that were queued"
    - "When a recipient's queue is full (1,000 messages), sender receives a QueueFull error envelope"
    - "Messages sent during flush are enqueued to bbolt (not delivered real-time) to preserve ordering"
    - "Expired messages are cleaned up by the background sweep goroutine"
  artifacts:
    - path: "relay/internal/hub/hub.go"
      provides: "Hub with bbolt message queue integration, batched flush, queue-full error response"
      contains: "MessageQueue"
    - path: "relay/internal/hub/client.go"
      provides: "Client with flushing flag to block real-time during flush"
      contains: "flushing"
    - path: "tests/cross-language/store-forward.integration.test.ts"
      provides: "Cross-language integration test proving offline queue and reconnect flush"
      min_lines: 80
  key_links:
    - from: "relay/internal/hub/hub.go"
      to: "relay/internal/store/messagequeue.go"
      via: "RouteMessage calls mq.Enqueue when recipient offline; register handler calls mq.FlushBatch"
      pattern: "mq\\.Enqueue|mq\\.FlushBatch"
    - from: "relay/internal/hub/hub.go"
      to: "relay/internal/hub/client.go"
      via: "Hub checks client.IsFlushing() before routing real-time; sets flushing state during flush"
      pattern: "IsFlushing|SetFlushing"
    - from: "relay/cmd/pinchd/main.go"
      to: "relay/internal/hub/hub.go"
      via: "main passes MessageQueue to NewHub"
      pattern: "hub\\.NewHub\\(blockStore.*messageQueue"
    - from: "skill/src/message-manager.ts"
      to: "gen/ts/pinch/v1/envelope_pb.ts"
      via: "MessageManager reads was_stored from DeliveryConfirm for sender feedback"
      pattern: "wasStored|was_stored"
---

<objective>
Wire the MessageQueue into the Hub's message routing and registration flow, implementing batched flush on reconnect, queue-full error feedback, flushing state management, and delivery confirmation correlation. Remove the in-memory pending buffer. Add TypeScript was_stored handling and cross-language integration tests.

Purpose: Complete the store-and-forward feature so agents that go offline receive all queued messages in order when they reconnect, with the sender informed of delayed delivery via the was_stored flag.

Output: Working store-and-forward with durable bbolt persistence, batched flush, queue-full feedback, and cross-language integration tests proving the full flow.
</objective>

<execution_context>
@/Users/riecekeck/.claude/get-shit-done/workflows/execute-plan.md
@/Users/riecekeck/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-store-and-forward/04-RESEARCH.md
@.planning/phases/04-store-and-forward/04-01-SUMMARY.md
@relay/internal/hub/hub.go
@relay/internal/hub/client.go
@relay/internal/hub/hub_test.go
@relay/internal/store/messagequeue.go
@relay/cmd/pinchd/main.go
@skill/src/message-manager.ts
@skill/src/relay-client.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Hub integration with MessageQueue, batched flush, and flushing state</name>
  <files>
    relay/internal/hub/hub.go
    relay/internal/hub/client.go
    relay/internal/hub/hub_test.go
    relay/cmd/pinchd/main.go
  </files>
  <action>
    **Part A: Client flushing state**

    Add to `relay/internal/hub/client.go`:
    - `flushing bool` field on Client struct (protected by hub's mu or atomic -- use sync/atomic for lock-free reads)
    - `flushKeys map[string][]byte` field: maps messageId (hex string from envelope) to bbolt key for delivery confirmation correlation during flush
    - `IsFlushing() bool` method: returns atomic flushing state
    - `SetFlushing(v bool)` method: sets atomic flushing state
    - `TrackFlushKey(messageId string, bboltKey []byte)`: stores mapping for flush correlation
    - `PopFlushKey(messageId string) ([]byte, bool)`: returns and removes the bbolt key for a confirmed message

    **Part B: Hub integration**

    Modify `relay/internal/hub/hub.go`:

    1. **NewHub signature change**: `func NewHub(blockStore *store.BlockStore, mq *store.MessageQueue) *Hub`
       - Add `mq *store.MessageQueue` field to Hub struct
       - Remove `pendingMessages map[string][]pendingMsg` field entirely
       - Remove `pendingMsg` struct
       - Remove `pendingTTL`, `pendingCleanupInterval`, `maxPendingPerAddress` constants

    2. **RouteMessage modification**: When recipient is offline (LookupClient returns false):
       - Call `h.mq.Enqueue(toAddress, from.Address(), envelope)` instead of appending to in-memory map
       - If `mq` is nil (for tests without queue), silently drop as before
       - If `Enqueue` returns `store.ErrQueueFull`:
         - Build a `QueueFull` error envelope (MESSAGE_TYPE_QUEUE_FULL) with `recipient_address` = toAddress and `reason` = "recipient message queue is full (limit: 1000)"
         - Serialize it and call `from.Send(queueFullEnvelope)` to notify the sender
         - Log the event with slog.Info
       - If recipient IS online but `client.IsFlushing()` is true:
         - Also enqueue to bbolt (messages during flush go to queue to preserve ordering)

    3. **Run registration handler**: When a client registers:
       - After adding to clients map, check `h.mq.Count(client.address)`
       - If count > 0:
         - Send `QueueStatus` envelope with pending_count to the client
         - Set `client.SetFlushing(true)`
         - Start a flush goroutine: `go h.flushQueuedMessages(client)`
       - If count == 0: normal real-time mode (no change)

    4. **New method `flushQueuedMessages(client *Client)`**:
       - Batch size: 50 (per user decision)
       - Loop: call `h.mq.FlushBatch(client.address, 50)`
       - For each entry in batch:
         - Extract message_id from the envelope bytes (unmarshal Envelope, read message_id field)
         - Call `client.TrackFlushKey(hex(messageId), entry.Key)` for delivery confirmation correlation
         - Call `client.Send(entry.Envelope)`
       - Small delay between batches (10ms) to avoid overwhelming the client's receive buffer
       - After all batches sent, set `client.SetFlushing(false)` -- real-time traffic can now flow
       - If client disconnects during flush (detect via client context cancellation), abort and leave remaining messages in bbolt

    5. **Delivery confirmation handling during flush**:
       - In `RouteMessage`, when processing a DELIVERY_CONFIRM message:
         - If the delivery confirm is routed TO a client that has `flushKeys` populated (the sender of original message), check if the confirmed message_id is in the sender's flushKeys
         - Actually, the simpler approach: the flush correlation is on the RECIPIENT side. When a flushed message gets a delivery confirmation from the recipient back to the original sender, we need to delete the queue entry.
         - Better approach per research: The flush goroutine sends messages. The RECIPIENT sends delivery confirmations back to the SENDER. But we need to delete the queue entry for the RECIPIENT's queue. So:
           - During flush, track `messageId -> bboltKey` on the flushing client
           - The flushing client's readPump receives delivery-related messages (the RECIPIENT sends the delivery confirm)
           - Wait, the flushing client IS the recipient. The recipient receives the flushed message, processes it, and sends a delivery confirmation back to the original sender via the relay.
           - The relay receives this delivery confirm from the recipient. In RouteMessage, BEFORE routing the delivery confirm to the sender, check if the recipient (the `from` client) has a flush key for this message_id.
           - If yes: call `h.mq.Remove(from.Address(), bboltKey)` to delete the message from the queue, then remove the key from flushKeys.
         - So in `RouteMessage`, add a check for `MESSAGE_TYPE_DELIVERY_CONFIRM`:
           ```
           if env.Type == MESSAGE_TYPE_DELIVERY_CONFIRM {
               dc := env.GetDeliveryConfirm()
               if dc != nil && from.flushKeys != nil {
                   msgIdHex := hex.EncodeToString(dc.MessageId)
                   if bboltKey, ok := from.PopFlushKey(msgIdHex); ok {
                       h.mq.Remove(from.Address(), bboltKey)
                   }
               }
           }
           ```
           This runs before the normal routing logic, so the confirm still gets delivered to the sender.

    6. **Remove cleanup ticker**: The `cleanupTicker` case in `Run()` is no longer needed (in-memory buffer removed). Remove it. The background sweep is started separately via `mq.StartSweep(ctx)` in main.go.

    7. **Remove PendingCount method**: No longer relevant (was for in-memory buffer testing).

    **Part C: main.go final wiring**

    Update `relay/cmd/pinchd/main.go`:
    - Create MessageQueue: `mq, err := store.NewMessageQueue(db, 1000, 7*24*time.Hour)` (1000 per-agent cap, 7-day TTL per user decision)
    - Pass to hub: `h := hub.NewHub(blockStore, mq)`
    - Start sweep: `go mq.StartSweep(ctx)` (runs until context cancelled)
    - Add `PINCH_RELAY_QUEUE_MAX` env var for configurable per-agent cap (default 1000)
    - Add `PINCH_RELAY_QUEUE_TTL` env var for configurable TTL in hours (default 168 = 7 days)

    **Part D: Update hub_test.go**

    Update all calls to `hub.NewHub(nil)` to `hub.NewHub(nil, nil)` (both blockStore and mq can be nil for basic tests).

    Add new test functions:
    1. `TestRouteMessageEnqueueOffline`: Create hub with real MessageQueue, send message to offline recipient, verify mq.Count > 0.
    2. `TestRouteMessageQueueFull`: Fill queue to cap, send one more, verify sender receives QueueFull envelope.
    3. `TestFlushOnReconnect`: Enqueue messages, register client, verify messages are flushed to client in order.
    4. `TestFlushBeforeRealTime`: Enqueue messages, register client, immediately send a real-time message, verify queued messages arrive before real-time message.
  </action>
  <verify>
    <automated>cd /Users/riecekeck/Coding/Pinch && go test ./relay/... -v -count=1 2>&1 | tail -30</automated>
    <manual>Verify hub_test.go new tests pass, main.go compiles, and all existing tests still pass</manual>
  </verify>
  <done>
    Hub uses MessageQueue for offline message storage instead of in-memory map.
    RouteMessage enqueues to bbolt when recipient offline or flushing.
    QueueFull error envelope sent to sender when queue cap exceeded.
    Registration triggers batched flush (50/batch) with QueueStatus sent first.
    Delivery confirmations during flush trigger queue entry deletion.
    Flushing flag prevents real-time bypass during flush.
    In-memory pending buffer completely removed.
    main.go passes MessageQueue to Hub and starts background sweep.
    All existing and new hub tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: TypeScript was_stored handling and cross-language integration tests</name>
  <files>
    skill/src/message-manager.ts
    skill/src/message-manager.test.ts
    tests/cross-language/store-forward.integration.test.ts
  </files>
  <action>
    **Part A: TypeScript message-manager updates**

    In `skill/src/message-manager.ts`:
    - In the delivery confirmation handler (the callback that processes incoming DELIVERY_CONFIRM envelopes):
      - Read the `wasStored` field from the DeliveryConfirm payload (already generated by buf from the proto change in Plan 01)
      - When updating the message store with the delivery confirmation state, also log whether `wasStored` is true: `console.log(\`Delivery confirmed for \${messageId} (stored: \${wasStored})\`)`
      - No behavior change needed -- the was_stored flag is informational for the sender. The delivery confirmation is processed the same way whether stored or not.

    - In the handler that processes incoming `MESSAGE_TYPE_QUEUE_STATUS` envelopes:
      - Add a new case to the envelope dispatch switch/if-chain
      - Read `QueueStatus.pendingCount` from the payload
      - Log: `console.log(\`Relay reports \${pendingCount} queued messages pending flush\`)`
      - No further action needed -- the agent just waits for the flushed messages to arrive

    - In the handler that processes incoming `MESSAGE_TYPE_QUEUE_FULL` envelopes:
      - Add a new case to the envelope dispatch
      - Read `QueueFull.recipientAddress` and `QueueFull.reason` from the payload
      - Log a warning: `console.warn(\`Message to \${recipientAddress} not queued: \${reason}\`)`
      - No retry logic -- the sender's human can decide what to do

    In `skill/src/message-manager.test.ts`:
    - Add test: `handles delivery confirmation with was_stored flag` -- create a mock delivery confirm envelope with was_stored=true, dispatch it, verify no errors.
    - Add test: `handles QueueStatus envelope` -- create a QueueStatus envelope with pending_count=5, dispatch it, verify no errors.
    - Add test: `handles QueueFull envelope` -- create a QueueFull envelope, dispatch it, verify no errors.

    **Part B: Cross-language integration test**

    Create `tests/cross-language/store-forward.integration.test.ts`:

    Follow the established integration test pattern from `skill/src/message-manager.integration.test.ts` and `skill/src/connection.integration.test.ts`: spawn a real Go relay, create two TypeScript agents with full crypto.

    Test scenario: "Offline agent receives queued messages on reconnect"
    1. Start Go relay with `PINCH_RELAY_DB` pointing to a temp file
    2. Create Agent A and Agent B, establish a connection between them (using existing helpers or inline setup)
    3. Disconnect Agent B (call disconnect)
    4. Agent A sends 3 encrypted messages to Agent B
    5. Wait briefly (100ms) for enqueue
    6. Reconnect Agent B
    7. Agent B should receive all 3 messages in order
    8. Agent A should eventually receive delivery confirmations with `was_stored=true` for all 3 messages
    9. Clean up: disconnect both agents, kill relay process

    Test scenario: "Queue full returns error to sender"
    1. Start Go relay with `PINCH_RELAY_QUEUE_MAX=5` env var
    2. Create Agent A and Agent B, establish connection
    3. Disconnect Agent B
    4. Agent A sends 6 messages (5 should succeed, 6th should trigger QueueFull)
    5. Verify Agent A receives a QueueFull envelope for the 6th message
    6. Clean up

    Use `vitest` with `{ timeout: 30000 }` for integration tests.
    Use `beforeAll`/`afterAll` for relay lifecycle.
    Follow the existing pattern of using `createAgent()` and `establishConnection()` helpers if they exist, or inline the setup.

    If `tests/cross-language/` directory doesn't exist, create it. Check if there's a vitest config that includes this path.
  </action>
  <verify>
    <automated>cd /Users/riecekeck/Coding/Pinch && npx vitest run skill/src/message-manager.test.ts --reporter=verbose 2>&1 | tail -20</automated>
    <manual>Run the cross-language integration test manually: cd /Users/riecekeck/Coding/Pinch && npx vitest run tests/cross-language/store-forward.integration.test.ts --reporter=verbose (requires Go relay to compile)</manual>
  </verify>
  <done>
    MessageManager handles was_stored flag on delivery confirmations (logs stored delivery).
    MessageManager handles QueueStatus envelope (logs pending count).
    MessageManager handles QueueFull envelope (logs warning).
    Unit tests verify all three new envelope handlers.
    Cross-language integration test proves: offline agent receives queued messages on reconnect in order, sender gets was_stored=true confirmations.
    Cross-language integration test proves: queue full returns QueueFull error to sender.
  </done>
</task>

</tasks>

<verification>
1. `go build ./relay/...` compiles with no errors
2. `go test ./relay/... -v -count=1` -- all hub and store tests pass
3. `npx vitest run skill/src/message-manager.test.ts` -- unit tests pass
4. `npx vitest run tests/cross-language/store-forward.integration.test.ts` -- integration tests pass
5. Manually verify: relay starts, BlockStore and MessageQueue share one bbolt file, background sweep runs
</verification>

<success_criteria>
- In-memory pending buffer completely removed from hub
- Hub routes offline messages to bbolt MessageQueue
- Batched flush (50/batch) on reconnect with QueueStatus sent first
- QueueFull error envelope sent to sender when 1,000-message cap exceeded
- Delivery confirmations during flush delete queue entries from bbolt
- Flushing flag prevents real-time message delivery until flush completes
- was_stored flag handled in TypeScript delivery confirmation processing
- Cross-language integration tests prove end-to-end store-and-forward flow
- All existing tests continue to pass
</success_criteria>

<output>
After completion, create `.planning/phases/04-store-and-forward/04-02-SUMMARY.md`
</output>
