---
phase: 03-encrypted-1-1-messaging
plan: 04
type: execute
wave: 3
depends_on: [03-03]
files_modified:
  - skill/SKILL.md
  - skill/HEARTBEAT.md
  - skill/src/tools/pinch-send.ts
  - skill/src/tools/pinch-connect.ts
  - skill/src/tools/pinch-contacts.ts
  - skill/src/tools/pinch-history.ts
  - skill/src/tools/pinch-status.ts
  - skill/src/index.ts
  - skill/src/tools/cli.ts
  - skill/src/tools/pinch-send.test.ts
  - skill/src/tools/pinch-history.test.ts
  - skill/package.json
autonomous: true
requirements: [SKIL-01, SKIL-02, SKIL-03, SKIL-04]

must_haves:
  truths:
    - "SKILL.md exists with valid YAML frontmatter defining the Pinch skill"
    - "HEARTBEAT.md surfaces pending inbound messages for human review"
    - "pinch_send encrypts and sends a message, returning the message_id"
    - "pinch_connect sends a connection request to a pinch address"
    - "pinch_contacts lists connections with status and autonomy level"
    - "pinch_history returns paginated message history"
    - "pinch_status returns delivery state for a message_id"
    - "All five tools are executable as CLI entry points"
  artifacts:
    - path: "skill/SKILL.md"
      provides: "OpenClaw skill definition"
      contains: "name: pinch"
      min_lines: 50
    - path: "skill/HEARTBEAT.md"
      provides: "Periodic heartbeat checklist"
      contains: "heartbeat"
    - path: "skill/src/tools/pinch-send.ts"
      provides: "pinch_send tool implementation"
      min_lines: 20
    - path: "skill/src/tools/pinch-connect.ts"
      provides: "pinch_connect tool implementation"
      min_lines: 15
    - path: "skill/src/tools/pinch-contacts.ts"
      provides: "pinch_contacts tool implementation"
      min_lines: 15
    - path: "skill/src/tools/pinch-history.ts"
      provides: "pinch_history tool implementation"
      min_lines: 20
    - path: "skill/src/tools/pinch-status.ts"
      provides: "pinch_status tool implementation"
      min_lines: 10
  key_links:
    - from: "skill/src/tools/pinch-send.ts"
      to: "skill/src/message-manager.ts"
      via: "MessageManager.sendMessage"
      pattern: "sendMessage"
    - from: "skill/src/tools/pinch-connect.ts"
      to: "skill/src/connection.ts"
      via: "ConnectionManager.sendRequest"
      pattern: "sendRequest"
    - from: "skill/src/tools/pinch-history.ts"
      to: "skill/src/message-store.ts"
      via: "MessageStore.getHistory"
      pattern: "getHistory"
    - from: "skill/src/tools/pinch-status.ts"
      to: "skill/src/message-store.ts"
      via: "MessageStore.getMessage"
      pattern: "getMessage"
    - from: "skill/SKILL.md"
      to: "skill/src/tools/"
      via: "tool descriptions referencing CLI scripts"
      pattern: "pinch_send|pinch_connect"
---

<objective>
Create the five OpenClaw skill tools (pinch_send, pinch_connect, pinch_contacts, pinch_history, pinch_status), write the SKILL.md and HEARTBEAT.md files, and wire everything together with a CLI entry point and integration test.

Purpose: This plan delivers the OpenClaw skill interface -- the surface through which agents actually use Pinch. Without these tools, the encryption and messaging infrastructure has no consumer.
Output: Five working skill tools, SKILL.md definition, HEARTBEAT.md checklist, CLI entry point, integration test.
</objective>

<execution_context>
@/Users/riecekeck/.claude/get-shit-done/workflows/execute-plan.md
@/Users/riecekeck/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-encrypted-1-1-messaging/03-CONTEXT.md
@.planning/phases/03-encrypted-1-1-messaging/03-RESEARCH.md
@.planning/phases/03-encrypted-1-1-messaging/03-03-SUMMARY.md
@skill/src/message-manager.ts
@skill/src/inbound-router.ts
@skill/src/connection.ts
@skill/src/connection-store.ts
@skill/src/message-store.ts
@skill/src/relay-client.ts
@skill/src/identity.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create five OpenClaw tool implementations and CLI entry point</name>
  <files>skill/src/tools/pinch-send.ts, skill/src/tools/pinch-connect.ts, skill/src/tools/pinch-contacts.ts, skill/src/tools/pinch-history.ts, skill/src/tools/pinch-status.ts, skill/src/tools/cli.ts, skill/src/index.ts, skill/package.json</files>
  <action>
Create the `skill/src/tools/` directory.

**Shared bootstrap (skill/src/tools/cli.ts):**
A shared module that initializes the runtime components needed by all tools:
- Reads PINCH_KEYPAIR_PATH env var (default: ~/.pinch/keypair.json)
- Reads PINCH_RELAY_URL env var (required, e.g. ws://localhost:8080)
- Reads PINCH_RELAY_HOST env var (default: localhost)
- Reads PINCH_DATA_DIR env var (default: ~/.pinch/data) -- for SQLite and connection store
- Loads or generates keypair from file (using loadKeypair from identity.ts)
- Creates RelayClient, ConnectionStore, MessageStore, ConnectionManager, MessageManager, InboundRouter
- Connects to relay and sets up handlers (ConnectionManager.setupHandlers, MessageManager.setupHandlers)
- Exports an async `bootstrap()` function that returns all the initialized components
- Exports a `shutdown()` function that disconnects and closes stores

Each tool module exports a single `run(args: string[]): Promise<void>` function that:
1. Calls bootstrap()
2. Parses CLI arguments
3. Performs its operation
4. Prints JSON result to stdout
5. Calls shutdown()

**pinch_send (skill/src/tools/pinch-send.ts):**
Args: `--to <address> --body <text> [--thread <id>] [--reply-to <id>] [--priority low|normal|urgent]`
1. Parse args
2. Call messageManager.sendMessage({ recipient, body, threadId, replyTo, priority })
3. Print JSON: `{ "message_id": "<id>", "status": "sent" }`
4. Shutdown

**pinch_connect (skill/src/tools/pinch-connect.ts):**
Args: `--to <address> --message <text>`
1. Parse args
2. Call connectionManager.sendRequest(toAddress, message)
3. Print JSON: `{ "status": "request_sent", "to": "<address>" }`
4. Shutdown

**pinch_contacts (skill/src/tools/pinch-contacts.ts):**
Args: `[--state active|pending_inbound|pending_outbound|blocked|revoked] [--format json|table]`
1. Parse args
2. Call connectionStore.listConnections() (filter by state if provided)
3. Print JSON array of connections with: address, state, autonomyLevel, nickname, lastActivity

**pinch_history (skill/src/tools/pinch-history.ts):**
Args: `[--connection <address>] [--thread <id>] [--limit N] [--offset N]` (default limit=20, offset=0)
For global inbox mode (no --connection): call messageStore.getHistory({ limit, offset })
For per-connection mode: call messageStore.getHistory({ connectionAddress, threadId, limit, offset })
Print JSON array of message records.

**pinch_status (skill/src/tools/pinch-status.ts):**
Args: `--id <message_id>`
1. Parse args
2. Call messageStore.getMessage(id)
3. If not found: `{ "error": "message not found" }` (exit 1)
4. If found: `{ "message_id": "<id>", "state": "<state>", "failure_reason": "<reason or null>", "updated_at": "<timestamp>" }`

**Update skill/package.json:**
Add a bin field (or scripts) for the CLI entry points so tools can be invoked:
```json
"bin": {
  "pinch-send": "./dist/tools/pinch-send.js",
  "pinch-connect": "./dist/tools/pinch-connect.js",
  "pinch-contacts": "./dist/tools/pinch-contacts.js",
  "pinch-history": "./dist/tools/pinch-history.js",
  "pinch-status": "./dist/tools/pinch-status.js"
}
```
Or if using tsx for direct execution, make each tool file self-executable with a `if (process.argv[1]...` check at the bottom that calls `run(process.argv.slice(2))`.

**Update skill/src/index.ts:**
Export MessageManager, MessageStore, InboundRouter, and delivery functions alongside existing exports. This makes the modules importable for programmatic use.

**Write basic tests (skill/src/tools/pinch-send.test.ts and skill/src/tools/pinch-history.test.ts):**
Unit test the argument parsing and output formatting (mock the managers). Test:
- pinch-send outputs valid JSON with message_id
- pinch-history outputs array of messages
- pinch-status outputs message state or error for not found
  </action>
  <verify>
    <automated>cd /Users/riecekeck/Coding/Pinch/skill && pnpm exec vitest run src/tools/ --reporter=verbose 2>&1 | tail -20</automated>
  </verify>
  <done>Five tool modules exist in skill/src/tools/ with run() functions. Shared bootstrap initializes all components from env vars. Each tool parses args, performs operation, prints JSON, and shuts down. Package.json updated with bin entries or self-executable main blocks. Tests for argument parsing and output formatting pass.</done>
</task>

<task type="auto">
  <name>Task 2: Write SKILL.md, HEARTBEAT.md, and cross-language integration test</name>
  <files>skill/SKILL.md, skill/HEARTBEAT.md, skill/src/message-manager.integration.test.ts</files>
  <action>
**Create SKILL.md (skill/SKILL.md):**

OpenClaw skill definition with YAML frontmatter and markdown body.

Frontmatter:
```yaml
---
name: pinch
description: Secure agent-to-agent encrypted messaging via the Pinch protocol. Send and receive end-to-end encrypted messages, manage connections, and check message history.
metadata:
  openclaw:
    requires:
      bins:
        - node
      env:
        - PINCH_RELAY_URL
        - PINCH_KEYPAIR_PATH
    emoji: "\U0001F4CC"
---
```

Markdown body sections:
1. **Overview** -- What Pinch does (2-3 sentences about secure agent-to-agent encrypted messaging)
2. **Setup** -- Required env vars (PINCH_RELAY_URL, PINCH_KEYPAIR_PATH, PINCH_DATA_DIR)
3. **Tools** -- Five tool descriptions with:
   - Tool name and one-line description
   - Parameters (required and optional)
   - Example invocation (bash command)
   - Example output (JSON)
   - Error cases
4. **Connection Lifecycle** -- How connections work (request -> approve -> active -> message)
5. **Message Delivery** -- Fire-and-forget with pinch_status for checking
6. **Autonomy Levels** -- Full Manual vs Full Auto behavior
7. **Guardrails** -- Message size limit (64KB), text only, no file attachments

**Create HEARTBEAT.md (skill/HEARTBEAT.md):**

OpenClaw heartbeat checklist that runs on each periodic agent turn (~30 min cycles).

```markdown
# Pinch Heartbeat

## Connection Check
- [ ] Verify WebSocket connection to relay is alive (check `pinch_status --connection`)
- [ ] If disconnected, attempt reconnection

## Pending Messages
- [ ] Check for pending inbound messages awaiting human review (Full Manual connections)
- [ ] Surface pending messages: "You have N pending Pinch messages from [addresses]"
- [ ] For each pending message, present: sender, preview (first 100 chars), timestamp, priority

## Delivery Updates
- [ ] Check for unconfirmed outbound messages older than 30 seconds
- [ ] Report any failed deliveries with failure reason

## Connection Requests
- [ ] Check for pending inbound connection requests
- [ ] Surface: "You have N pending Pinch connection requests from [addresses]"
```

**Create cross-language integration test (skill/src/message-manager.integration.test.ts):**

Integration test that validates the full encrypted message roundtrip across Go relay and TypeScript agents. Follow the established pattern from connection.integration.test.ts (spawn real Go relay, connect two TypeScript agents).

Test flow:
1. Start Go relay (go run ./relay/cmd/pinchd/)
2. Generate two keypairs (Agent A and Agent B)
3. Connect both agents to relay (auth handshake)
4. Agent A sends connection request to Agent B
5. Agent B approves connection request
6. Agent A sends encrypted message to Agent B via MessageManager.sendMessage
7. Agent B receives, decrypts, and verifies the message
8. Agent B sends delivery confirmation back to Agent A
9. Agent A receives and verifies the delivery confirmation
10. Assert: Agent B's decrypted plaintext matches what Agent A sent
11. Assert: Agent A's message state updated to "delivered"
12. Assert: relay never saw plaintext (it only forwarded opaque envelopes)

Tests:
- Full encrypted message roundtrip (A sends to B, B decrypts)
- Delivery confirmation roundtrip (B confirms to A, A verifies)
- Full Manual routing: message from a full_manual connection is stored with escalated_to_human state
- Message size limit: sending >60KB body throws client-side error
- Message relay latency: assert full send-receive roundtrip completes in under 500ms (conservative bound for RELY-04 non-blocking dispatch)

Clean up: kill relay process, remove temp data directories.
  </action>
  <verify>
    <automated>cd /Users/riecekeck/Coding/Pinch/skill && pnpm exec vitest run src/message-manager.integration.test.ts --reporter=verbose --timeout 60000 2>&1 | tail -30</automated>
  </verify>
  <done>SKILL.md defines the Pinch skill with all five tools documented. HEARTBEAT.md provides periodic checklist for pending messages and connection health. Integration test validates full encrypted message roundtrip across Go relay and TypeScript agents: encrypt, send, relay, receive, decrypt, confirm.</done>
</task>

</tasks>

<verification>
- `ls skill/SKILL.md skill/HEARTBEAT.md` -- both files exist
- `grep -q "name: pinch" skill/SKILL.md` -- valid frontmatter
- `ls skill/src/tools/pinch-send.ts skill/src/tools/pinch-connect.ts skill/src/tools/pinch-contacts.ts skill/src/tools/pinch-history.ts skill/src/tools/pinch-status.ts` -- all five tools exist
- `cd skill && pnpm exec vitest run` -- all tests pass (unit + integration)
- Integration test proves end-to-end encrypted message delivery through Go relay
</verification>

<success_criteria>
- SKILL.md has valid OpenClaw YAML frontmatter with name, description, requires
- HEARTBEAT.md surfaces pending messages and connection health
- All five tools (pinch_send, pinch_connect, pinch_contacts, pinch_history, pinch_status) are executable
- pinch_send encrypts with NaCl box, sends through relay, recipient decrypts
- pinch_status shows delivery state progression (sent -> delivered)
- Full Manual messages (state: escalated_to_human) are surfaced in HEARTBEAT.md flow
- Cross-language integration test passes
</success_criteria>

<output>
After completion, create `.planning/phases/03-encrypted-1-1-messaging/03-04-SUMMARY.md`
</output>
