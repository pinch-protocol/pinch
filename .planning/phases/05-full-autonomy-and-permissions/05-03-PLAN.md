---
phase: 05-full-autonomy-and-permissions
plan: 03
type: execute
wave: 3
depends_on: [05-01, 05-02]
files_modified:
  - skill/src/autonomy/circuit-breaker.ts
  - skill/src/autonomy/circuit-breaker.test.ts
  - skill/src/autonomy/enforcement-pipeline.ts
  - skill/src/autonomy/enforcement-pipeline.test.ts
  - skill/src/tools/cli.ts
  - skill/src/inbound-router.ts
  - skill/src/message-manager.ts
  - skill/src/message-store.ts
  - skill/src/index.ts
  - skill/SKILL.md
  - skill/HEARTBEAT.md
autonomous: true
requirements: [AUTO-10]

must_haves:
  truths:
    - "Circuit breaker auto-downgrades a connection to Full Manual when anomalous behavior is detected"
    - "All four circuit breaker triggers are active: message flood, permission violations, spending cap exceeded, boundary probing"
    - "Circuit breaker downgrade is straight to Full Manual, no gradual step-down"
    - "Human must manually re-upgrade after circuit breaker trips -- no automatic recovery"
    - "Circuit breaker trip event appears in activity feed with trigger details and warning badge"
    - "circuitBreakerTripped flag persists on connection across restarts"
    - "Enforcement pipeline runs: permissions check -> circuit breaker recording -> autonomy routing"
    - "Auto-respond policy evaluation logs every decision to activity feed with action, confidence, and reasoning"
    - "MessageManager routes inbound messages through enforcementPipeline.process(), not inboundRouter.route() directly"
    - "Bootstrap creates all new autonomy components and wires them into the pipeline"
    - "SKILL.md documents autonomy levels, permissions, and the pinch-autonomy / pinch-permissions tools"
  artifacts:
    - path: "skill/src/autonomy/circuit-breaker.ts"
      provides: "CircuitBreaker with sliding window counters for 4 trigger types"
      exports: ["CircuitBreaker"]
    - path: "skill/src/autonomy/enforcement-pipeline.ts"
      provides: "EnforcementPipeline wiring permissions -> circuit breaker -> autonomy routing"
      exports: ["EnforcementPipeline"]
    - path: "skill/src/tools/cli.ts"
      provides: "Updated bootstrap creating all autonomy components"
      contains: "EnforcementPipeline"
    - path: "skill/SKILL.md"
      provides: "Updated skill definition with autonomy and permissions documentation"
      contains: "pinch-autonomy"
  key_links:
    - from: "skill/src/autonomy/enforcement-pipeline.ts"
      to: "skill/src/autonomy/permissions-enforcer.ts"
      via: "permissions check as first step"
      pattern: "permissionsEnforcer\\.check"
    - from: "skill/src/autonomy/enforcement-pipeline.ts"
      to: "skill/src/autonomy/circuit-breaker.ts"
      via: "recording events and checking trip state"
      pattern: "circuitBreaker\\.record"
    - from: "skill/src/autonomy/enforcement-pipeline.ts"
      to: "skill/src/inbound-router.ts"
      via: "autonomy routing as final step"
      pattern: "inboundRouter\\.route"
    - from: "skill/src/autonomy/circuit-breaker.ts"
      to: "skill/src/connection-store.ts"
      via: "auto-downgrade sets autonomy to full_manual"
      pattern: "connectionStore\\.setAutonomy.*full_manual"
    - from: "skill/src/tools/cli.ts"
      to: "skill/src/autonomy/enforcement-pipeline.ts"
      via: "bootstrap creates pipeline and wires to message manager"
      pattern: "new EnforcementPipeline"
    - from: "skill/src/message-manager.ts"
      to: "skill/src/autonomy/enforcement-pipeline.ts"
      via: "inbound message processing routes through enforcementPipeline.process() instead of inboundRouter.route()"
      pattern: "enforcementPipeline\\.process"
---

<objective>
Implement circuit breakers with sliding window counters for 4 trigger types, wire the complete enforcement pipeline (permissions -> circuit breaker -> autonomy routing), update bootstrap to create all autonomy components, and update SKILL.md/HEARTBEAT.md with new tools and behaviors.

Purpose: Circuit breakers complete Pinch's safety infrastructure -- they protect against anomalous behavior by auto-downgrading connections to Full Manual. The enforcement pipeline ties everything together into a single entry point for inbound message processing. This plan completes Phase 5.

Output: CircuitBreaker class, EnforcementPipeline class, updated bootstrap, updated SKILL.md and HEARTBEAT.md.
</objective>

<execution_context>
@/Users/riecekeck/.claude/get-shit-done/workflows/execute-plan.md
@/Users/riecekeck/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-full-autonomy-and-permissions/05-01-SUMMARY.md
@.planning/phases/05-full-autonomy-and-permissions/05-02-SUMMARY.md

@skill/src/autonomy/activity-feed.ts
@skill/src/autonomy/permissions-enforcer.ts
@skill/src/autonomy/policy-evaluator.ts
@skill/src/inbound-router.ts
@skill/src/connection-store.ts
@skill/src/tools/cli.ts
@skill/src/message-manager.ts
@skill/SKILL.md
@skill/HEARTBEAT.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create CircuitBreaker and EnforcementPipeline</name>
  <files>
    skill/src/autonomy/circuit-breaker.ts
    skill/src/autonomy/circuit-breaker.test.ts
    skill/src/autonomy/enforcement-pipeline.ts
    skill/src/autonomy/enforcement-pipeline.test.ts
    skill/src/inbound-router.ts
  </files>
  <action>
**autonomy/circuit-breaker.ts (NEW):**

Create a `CircuitBreaker` class with sliding window counters. Per locked decisions from CONTEXT.md:
- 4 trigger types: message_flood, permission_violation, spending_exceeded, boundary_probe
- Downgrade behavior: straight to Full Manual on any trigger
- Recovery: human must manually re-upgrade (no automatic recovery)
- Notification: trip event appears in activity feed with trigger details + warning badge

Constructor: `(connectionStore: ConnectionStore, activityFeed: ActivityFeed, config?: CircuitBreakerConfig)`

```typescript
export interface CircuitBreakerConfig {
  /** Max messages per window before flood trip. Default: 50. */
  floodThreshold: number;
  /** Window size for flood detection in ms. Default: 60_000 (1 minute). */
  floodWindowMs: number;
  /** Max permission violations per window before trip. Default: 5. */
  violationThreshold: number;
  /** Window size for violation detection in ms. Default: 300_000 (5 minutes). */
  violationWindowMs: number;
  /** Max boundary probe escalations per window before trip. Default: 3. */
  boundaryProbeThreshold: number;
  /** Window for boundary probe detection in ms. Default: 600_000 (10 minutes). */
  boundaryProbeWindowMs: number;
}

export const DEFAULT_CIRCUIT_BREAKER_CONFIG: CircuitBreakerConfig = {
  floodThreshold: 50,
  floodWindowMs: 60_000,
  violationThreshold: 5,
  violationWindowMs: 300_000,
  boundaryProbeThreshold: 3,
  boundaryProbeWindowMs: 600_000,
};
```

Sliding window implementation (per research Pattern 2):
- `private events: Map<string, Array<{ timestamp: number; type: TriggerType }>>` -- in-memory, resets on restart (which is fine -- the autonomy downgrade is persisted via connectionStore).
- `recordMessage(connectionAddress: string): void` -- record a message event, then check if flood threshold exceeded.
- `recordViolation(connectionAddress: string, type: 'permission_violation' | 'spending_exceeded' | 'boundary_probe'): void` -- record a violation event, then check threshold.
- `private checkAndTrip(connectionAddress: string): boolean` -- check all counters against thresholds. If any exceeded:
  1. Call `connectionStore.setAutonomy(connectionAddress, 'full_manual')` to persist downgrade.
  2. Call `connectionStore.updateConnection(connectionAddress, { circuitBreakerTripped: true })`.
  3. Save connection store: `connectionStore.save()`.
  4. Call `activityFeed.record({ connectionAddress, eventType: 'circuit_breaker_tripped', badge: 'circuit_breaker', details: JSON.stringify({ trigger, count, threshold, windowMs }) })`.
  5. Return true (tripped).
- `isTripped(connectionAddress: string): boolean` -- check if the connection's `circuitBreakerTripped` flag is true (reads from persisted state, not in-memory counters).
- `private pruneOldEvents(connectionAddress: string): void` -- remove events older than the longest window from the events map (prevent unbounded memory growth).

Per locked decision: spending_exceeded is a trigger type. For v1, spending tracking is not fully implemented (no actual dollar tracking yet), but the circuit breaker can record spending violations when they are reported by the PermissionsEnforcer. The threshold and window are configurable.

**autonomy/circuit-breaker.test.ts (NEW):**
- Test: single message does not trip circuit breaker.
- Test: messages exceeding flood threshold trip circuit breaker and downgrade to full_manual.
- Test: permission violations exceeding threshold trip circuit breaker.
- Test: boundary probes exceeding threshold trip circuit breaker.
- Test: circuit breaker trip records activity feed event with trigger details.
- Test: circuit breaker trip sets circuitBreakerTripped flag on connection.
- Test: isTripped returns true for tripped connection.
- Test: old events are pruned (events outside window don't count toward threshold).
- Test: human re-upgrade clears circuitBreakerTripped flag (via setAutonomy, tested in Plan 01).

Use a test ConnectionStore (in-memory JSON) and test ActivityFeed (in-memory SQLite via `:memory:`).

**autonomy/enforcement-pipeline.ts (NEW):**

Create an `EnforcementPipeline` class that orchestrates the complete inbound message processing flow. This is the single entry point for processing an inbound message after decryption.

Constructor: `(permissionsEnforcer: PermissionsEnforcer, circuitBreaker: CircuitBreaker, inboundRouter: InboundRouter, policyEvaluator: PolicyEvaluator, connectionStore: ConnectionStore, messageStore: MessageStore, activityFeed: ActivityFeed)`

Method: `async process(message: MessageRecord, connectionAddress: string): Promise<RoutedMessage>`

Pipeline steps:
1. **Permissions check**: Call `permissionsEnforcer.check(message.body, connectionAddress)`.
   - If denied AND not escalateToHuman: record violation via `circuitBreaker.recordViolation(connectionAddress, result.violationType)`, update message state to `"failed"` with failureReason, return failed RoutedMessage.
   - If denied AND escalateToHuman: update message state to `"escalated_to_human"` (human decides), return escalated RoutedMessage.
2. **Circuit breaker recording**: Call `circuitBreaker.recordMessage(connectionAddress)`.
   - If the circuit breaker just tripped (check `circuitBreaker.isTripped(connectionAddress)` after recording), the connection is now Full Manual. The InboundRouter will pick up the new autonomy level naturally.
3. **Autonomy-level routing**: Call `inboundRouter.route(message, connectionAddress)`.
   - The InboundRouter reads the current autonomy level from the connection store. If the circuit breaker just downgraded it, the message will be routed as Full Manual (escalated_to_human).
4. **Auto-respond policy evaluation** (if route returned `pending_policy_eval`):
   - Get the connection's `autoRespondPolicy` from the connection store.
   - If no policy set, escalate to human (safe default).
   - Call `policyEvaluator.evaluatePolicy({ policy, messageBody: message.body, senderAddress: connectionAddress, connectionNickname: connection.nickname })`.
   - If `allow`: update message state to `"read_by_agent"`, return.
   - If `deny`: update message state to `"failed"` with reasoning, return.
   - If `escalate` or low confidence: update message state to `"escalated_to_human"`, return.
   - On error (LLM unavailable): update message state to `"escalated_to_human"` (safe default per pitfall 5).
   - **After EVERY auto_respond evaluation outcome** (allow, deny, escalate, or error), call `activityFeed.record()` with `eventType: 'auto_respond_decision'`, the `messageId`, `badge: 'auto_respond'`, and `details: JSON.stringify({ action: decision.action, confidence: decision.confidence, reasoning: decision.reasoning })`. This satisfies AUTO-05's "logs everything" requirement -- every policy evaluation is recorded in the activity feed.

Per research pitfall 1 (race condition): Read the autonomy level at the START of step 3 and use that snapshot. The pipeline captures the level before any async work. If the level changes mid-processing, the current message completes under the original level.

**autonomy/enforcement-pipeline.test.ts (NEW):**

Use mock implementations for all dependencies.

Tests:
- Test: message passes permissions and routes via full_manual -> escalated_to_human.
- Test: message fails permissions -> failed state, violation recorded.
- Test: message fails permissions with escalateToHuman -> escalated_to_human state.
- Test: circuit breaker trips during processing -> subsequent routing sees full_manual.
- Test: auto_respond with LLM allow -> read_by_agent.
- Test: auto_respond with LLM deny -> failed.
- Test: auto_respond with LLM escalate -> escalated_to_human.
- Test: auto_respond with no policy -> escalated_to_human.
- Test: auto_respond with LLM error -> escalated_to_human (safe default).
- Test: auto_respond evaluation records activity feed entry with eventType 'auto_respond_decision', badge 'auto_respond', and details containing action/confidence/reasoning from PolicyDecision.

**inbound-router.ts changes:**
- No structural changes needed from Plan 01's implementation.
- Ensure the `route()` method is compatible with being called by the EnforcementPipeline (it already is -- takes MessageRecord and connectionAddress, returns RoutedMessage).
  </action>
  <verify>
    <automated>cd /Users/riecekeck/Coding/Pinch && npx vitest run skill/src/autonomy/circuit-breaker.test.ts skill/src/autonomy/enforcement-pipeline.test.ts --reporter=verbose 2>&1 | tail -40</automated>
    <manual>Verify circuit breaker trips at configured thresholds and persists downgrade</manual>
  </verify>
  <done>CircuitBreaker tracks 4 trigger types with sliding window counters and auto-downgrades to Full Manual. EnforcementPipeline orchestrates permissions -> circuit breaker -> autonomy routing -> policy evaluation. All auto-respond evaluation uses PolicyEvaluator with safe fallbacks. All tests pass.</done>
</task>

<task type="auto">
  <name>Task 2: Wire enforcement pipeline into bootstrap and message flow, update skill docs</name>
  <files>
    skill/src/tools/cli.ts
    skill/src/message-manager.ts
    skill/src/message-store.ts
    skill/src/index.ts
    skill/SKILL.md
    skill/HEARTBEAT.md
  </files>
  <action>
**tools/cli.ts changes:**

Update the `bootstrap()` function to create all new autonomy components and wire them into the pipeline.

1. Import new modules:
   - `ActivityFeed` from `"../autonomy/activity-feed.js"`
   - `PermissionsEnforcer` from `"../autonomy/permissions-enforcer.js"`
   - `NoOpPolicyEvaluator` from `"../autonomy/policy-evaluator.js"`
   - `CircuitBreaker` from `"../autonomy/circuit-breaker.js"`
   - `EnforcementPipeline` from `"../autonomy/enforcement-pipeline.js"`

2. In the component creation section (after `messageStore` is created):
   ```typescript
   // Activity feed uses the same SQLite database as messages
   const activityFeed = new ActivityFeed(messageStore.getDb());
   ```
   NOTE: MessageStore needs a `getDb()` method to expose its Database instance. Add this method to MessageStore: `getDb(): DatabaseType { return this.db; }`. This is a minimal change -- the ActivityFeed shares the same WAL-mode database.

3. Create autonomy components:
   ```typescript
   const policyEvaluator = new NoOpPolicyEvaluator();
   const permissionsEnforcer = new PermissionsEnforcer(connectionStore, policyEvaluator);
   const circuitBreaker = new CircuitBreaker(connectionStore, activityFeed);
   ```

4. Pass `activityFeed` to the `InboundRouter` constructor (already updated in Plan 01).

5. Create the enforcement pipeline:
   ```typescript
   const enforcementPipeline = new EnforcementPipeline(
     permissionsEnforcer,
     circuitBreaker,
     inboundRouter,
     policyEvaluator,
     connectionStore,
     messageStore,
     activityFeed,
   );
   ```

6. Update `BootstrapResult` interface to include the new components:
   - `activityFeed: ActivityFeed`
   - `permissionsEnforcer: PermissionsEnforcer`
   - `circuitBreaker: CircuitBreaker`
   - `enforcementPipeline: EnforcementPipeline`

7. Add the new components to the returned `bootstrapped` object.

8. Pass `enforcementPipeline` to the `MessageManager` constructor (replacing the direct `inboundRouter` dependency -- see message-manager.ts changes below).

**message-store.ts changes:**

Add `getDb()` method to MessageStore:
```typescript
/** Expose the underlying SQLite database for shared use (e.g., ActivityFeed). */
getDb(): DatabaseType { return this.db; }
```
This is a 1-line addition. The ActivityFeed shares the same WAL-mode database.

**message-manager.ts changes (CRITICAL -- wires the pipeline into the actual message flow):**

This is the key wiring change. Currently, `MessageManager` calls `this.inboundRouter.route(messageRecord, senderAddress)` directly on line 231. The enforcement pipeline must replace this call:

1. Change the `MessageManager` constructor to accept `enforcementPipeline: EnforcementPipeline` instead of `inboundRouter: InboundRouter`. Update the constructor parameter and the import:
   - Remove: `import type { InboundRouter } from "./inbound-router.js";`
   - Add: `import type { EnforcementPipeline } from "./autonomy/enforcement-pipeline.js";`
   - Replace constructor param: `private inboundRouter: InboundRouter` -> `private enforcementPipeline: EnforcementPipeline`

2. Replace the inbound routing call (line ~231):
   - Before: `this.inboundRouter.route(messageRecord, senderAddress);`
   - After: `await this.enforcementPipeline.process(messageRecord, senderAddress);`
   Note: `process()` is async, so the call must be awaited. The `handleIncomingMessage` method is already async, so this is compatible.

3. Update the corresponding `cli.ts` bootstrap to pass `enforcementPipeline` to `new MessageManager(...)` instead of `inboundRouter`:
   ```typescript
   const messageManager = new MessageManager(
     relayClient,
     connectionStore,
     messageStore,
     keypair,
     enforcementPipeline,  // was: inboundRouter
   );
   ```

This is the critical link: without this change, the EnforcementPipeline would be created but never invoked, and all inbound messages would bypass permissions enforcement and circuit breakers.

**index.ts changes:**

Export the new modules:
- `CircuitBreaker`, `CircuitBreakerConfig`, `DEFAULT_CIRCUIT_BREAKER_CONFIG` from `"./autonomy/circuit-breaker.js"`
- `EnforcementPipeline` from `"./autonomy/enforcement-pipeline.js"`

**SKILL.md changes:**

Update the SKILL.md to document the new autonomy levels, permissions, and tools. Add sections:

1. Under the existing "Autonomy Levels" section, expand to document all 4 tiers:
   - Full Manual: "Every inbound message is queued for your approval. Nothing happens until you act."
   - Notify: "Agent processes messages autonomously. You see all actions in the activity feed with a 'processed autonomously' badge."
   - Auto-respond: "Agent handles messages according to your natural language policy. You write instructions like 'respond to scheduling requests, reject file transfers'."
   - Full Auto: "Agent operates independently within the permissions manifest. Everything logged to audit trail."

2. Add a new "Permissions" section documenting the permissions manifest:
   - Calendar, files, actions, spending caps, information boundaries, custom categories
   - Deny-by-default: new connections deny everything until you configure permissions

3. Add tool documentation for `pinch-autonomy`:
   ```
   ## pinch-autonomy
   Set the autonomy level for a connection.

   Arguments:
   - --address (required): Peer's pinch: address
   - --level (required): full_manual, notify, auto_respond, full_auto
   - --confirmed: Required when upgrading to full_auto
   - --policy: Natural language policy text (for auto_respond)

   Example: pinch-autonomy --address pinch:abc@relay --level notify
   ```

4. Add tool documentation for `pinch-permissions`:
   ```
   ## pinch-permissions
   View or configure the permissions manifest for a connection.

   Arguments:
   - --address (required): Peer's pinch: address
   - --show: Display current permissions
   - --calendar, --files, --actions: Set capability tiers
   - --spending-per-tx, --spending-per-day, --spending-per-connection: Set spending caps
   - --add-boundary, --remove-boundary: Manage information boundaries
   - --add-category, --remove-category: Manage custom categories

   Example: pinch-permissions --address pinch:abc@relay --calendar free_busy_only --files none
   ```

5. Add a "Circuit Breakers" section:
   - Explain that anomalous behavior auto-downgrades to Full Manual
   - Four triggers: message flood, permission violations, spending cap exceeded, boundary probing
   - Recovery requires manual re-upgrade via pinch-autonomy

**HEARTBEAT.md changes:**

Add to the periodic checklist:
- "Check for circuit breaker events in the activity feed"
- "Review connections with warning badges"
- "Check for pending_policy_eval messages (Auto-respond awaiting evaluation)"
  </action>
  <verify>
    <automated>cd /Users/riecekeck/Coding/Pinch && npx vitest run --reporter=verbose 2>&1 | tail -50</automated>
    <manual>Verify SKILL.md documents all 4 autonomy levels and both new tools</manual>
  </verify>
  <done>Bootstrap creates all autonomy components and wires them into the enforcement pipeline. MessageManager routes inbound messages through enforcementPipeline.process() instead of inboundRouter.route() directly. MessageStore exposes getDb() for ActivityFeed sharing. SKILL.md documents 4 autonomy levels, permissions manifest, pinch-autonomy tool, pinch-permissions tool, and circuit breakers. HEARTBEAT.md includes circuit breaker and Auto-respond monitoring. All tests pass including full regression suite.</done>
</task>

</tasks>

<verification>
Run the complete test suite to verify no regressions:
```bash
cd /Users/riecekeck/Coding/Pinch && npx vitest run --reporter=verbose 2>&1 | tail -60
```

Verify enforcement pipeline ordering:
```bash
grep -n "permissionsEnforcer\|circuitBreaker\|inboundRouter" skill/src/autonomy/enforcement-pipeline.ts
```

Verify SKILL.md has new tool documentation:
```bash
grep -n "pinch-autonomy\|pinch-permissions\|circuit.breaker" skill/SKILL.md
```

Verify bootstrap creates all components:
```bash
grep -n "ActivityFeed\|PermissionsEnforcer\|CircuitBreaker\|EnforcementPipeline" skill/src/tools/cli.ts
```

Verify MessageManager uses enforcementPipeline instead of inboundRouter:
```bash
grep -n "enforcementPipeline\|inboundRouter" skill/src/message-manager.ts
```

Verify auto_respond decisions are logged to activity feed:
```bash
grep -n "auto_respond_decision\|activityFeed\.record" skill/src/autonomy/enforcement-pipeline.ts
```
</verification>

<success_criteria>
- CircuitBreaker tracks all 4 trigger types with configurable sliding window thresholds
- Circuit breaker trips -> connection downgraded to Full Manual immediately
- Circuit breaker trip persists circuitBreakerTripped flag (survives restart)
- Circuit breaker trip creates activity feed event with trigger details and warning badge
- Human re-upgrade via setAutonomy clears circuitBreakerTripped flag
- No automatic circuit breaker recovery (locked decision)
- EnforcementPipeline runs: permissions -> circuit breaker -> autonomy routing -> policy evaluation
- Auto-respond policy evaluation returns allow/deny/escalate with safe fallbacks
- Auto-respond policy evaluation logs every decision to activity feed (eventType: auto_respond_decision)
- MessageManager calls enforcementPipeline.process() instead of inboundRouter.route() directly
- Bootstrap creates all new components and wires them correctly
- SKILL.md documents all 4 autonomy levels, permissions, both new tools, circuit breakers
- HEARTBEAT.md includes circuit breaker and Auto-respond monitoring items
- All new and existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/05-full-autonomy-and-permissions/05-03-SUMMARY.md`
</output>
