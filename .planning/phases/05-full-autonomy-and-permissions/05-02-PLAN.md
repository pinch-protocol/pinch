---
phase: 05-full-autonomy-and-permissions
plan: 02
type: execute
wave: 2
depends_on: [05-01]
files_modified:
  - skill/src/autonomy/permissions-manifest.ts
  - skill/src/autonomy/permissions-manifest.test.ts
  - skill/src/autonomy/permissions-enforcer.ts
  - skill/src/autonomy/permissions-enforcer.test.ts
  - skill/src/autonomy/policy-evaluator.ts
  - skill/src/autonomy/policy-evaluator.test.ts
  - skill/src/connection-store.ts
  - skill/src/tools/pinch-permissions.ts
  - skill/src/tools/pinch-permissions.test.ts
  - skill/src/index.ts
  - skill/package.json
autonomous: true
requirements: [AUTO-05, AUTO-08, AUTO-09]

must_haves:
  truths:
    - "Every new connection gets a deny-all default permissions manifest"
    - "Permissions manifest defines domain-specific capability tiers: calendar, files, actions, spending, information boundaries, custom categories"
    - "PermissionsEnforcer checks the manifest BEFORE any content reaches the LLM or autonomy routing"
    - "Denied messages are rejected with a clear reason, and the violation is recorded for circuit breaker tracking"
    - "Information boundaries use a PolicyEvaluator interface for LLM-evaluated natural language exclusions"
    - "Auto-respond messages are evaluated by the PolicyEvaluator against the human-written natural language policy"
    - "When the LLM is uncertain about an information boundary, the message is blocked and escalated to the human"
    - "When the LLM is unavailable, Auto-respond falls back to escalated_to_human (safe default)"
    - "Human can configure permissions for any connection via pinch-permissions tool"
  artifacts:
    - path: "skill/src/autonomy/permissions-manifest.ts"
      provides: "PermissionsManifest type with domain-specific capability tiers and defaultPermissionsManifest()"
      exports: ["PermissionsManifest", "defaultPermissionsManifest"]
    - path: "skill/src/autonomy/permissions-enforcer.ts"
      provides: "PermissionsEnforcer checking manifest before content reaches LLM"
      exports: ["PermissionsEnforcer"]
    - path: "skill/src/autonomy/policy-evaluator.ts"
      provides: "PolicyEvaluator interface for LLM-evaluated policies and boundaries"
      exports: ["PolicyEvaluator", "PolicyDecision"]
    - path: "skill/src/tools/pinch-permissions.ts"
      provides: "CLI tool for configuring permissions manifest"
      contains: "pinch-permissions"
  key_links:
    - from: "skill/src/autonomy/permissions-enforcer.ts"
      to: "skill/src/connection-store.ts"
      via: "reads permissionsManifest from connection"
      pattern: "connection\\.permissionsManifest"
    - from: "skill/src/autonomy/permissions-enforcer.ts"
      to: "skill/src/autonomy/policy-evaluator.ts"
      via: "delegates information boundary checks to PolicyEvaluator"
      pattern: "policyEvaluator\\.checkInformationBoundary"
    - from: "skill/src/connection-store.ts"
      to: "skill/src/autonomy/permissions-manifest.ts"
      via: "addConnection assigns defaultPermissionsManifest()"
      pattern: "defaultPermissionsManifest"
---

<objective>
Implement the inbound permissions manifest (deny-by-default with domain-specific capability tiers), a PermissionsEnforcer that gates content before autonomy routing, a PolicyEvaluator interface for LLM-evaluated natural language policies and information boundaries, and a pinch-permissions CLI tool for configuration.

Purpose: The permissions manifest is Pinch's core trust mechanism -- it defines WHAT each connection can do, while autonomy defines HOW messages are processed. Together they create the graduated trust model described in CONTEXT.md. The PolicyEvaluator interface enables the novel Auto-respond tier and information boundary checking.

Output: PermissionsManifest type, PermissionsEnforcer class, PolicyEvaluator interface, pinch-permissions tool, updated connection-store with manifest storage.
</objective>

<execution_context>
@/Users/riecekeck/.claude/get-shit-done/workflows/execute-plan.md
@/Users/riecekeck/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-full-autonomy-and-permissions/05-01-SUMMARY.md

@skill/src/connection-store.ts
@skill/src/inbound-router.ts
@skill/src/autonomy/activity-feed.ts
@skill/src/tools/cli.ts
@skill/src/tools/pinch-send.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create PermissionsManifest type, PermissionsEnforcer, and PolicyEvaluator interface</name>
  <files>
    skill/src/autonomy/permissions-manifest.ts
    skill/src/autonomy/permissions-manifest.test.ts
    skill/src/autonomy/permissions-enforcer.ts
    skill/src/autonomy/permissions-enforcer.test.ts
    skill/src/autonomy/policy-evaluator.ts
    skill/src/autonomy/policy-evaluator.test.ts
    skill/src/connection-store.ts
  </files>
  <action>
**autonomy/permissions-manifest.ts (NEW):**

Define types per locked decisions from CONTEXT.md:

```typescript
/** Calendar permission tiers (structural -- no LLM needed). */
export type CalendarPermission = 'none' | 'free_busy_only' | 'full_details' | 'propose_and_book';

/** File permission tiers (structural). */
export type FilePermission = 'none' | 'specific_folders' | 'everything';

/** Action permission (structural). */
export type ActionPermission = 'none' | 'scoped' | 'full';

/** Spending caps in USD. 0 = disabled/blocked. */
export interface SpendingCaps {
  perTransaction: number;
  perDay: number;
  perConnection: number;
}

/** User-defined category (LLM-interpreted). */
export interface CustomCategory {
  name: string;
  description: string;  // Natural language rule
  allowed: boolean;     // Default posture for this category
}

/** The complete permissions manifest for a connection. */
export interface PermissionsManifest {
  calendar: CalendarPermission;
  files: FilePermission;
  allowedFolders?: string[];       // Only when files === 'specific_folders'
  actions: ActionPermission;
  actionScopes?: string[];         // Only when actions === 'scoped'
  spending: SpendingCaps;
  informationBoundaries: string[]; // Natural language exclusions, LLM-evaluated
  customCategories: CustomCategory[];
}

/** Returns a deny-all manifest (Pinch core principle: deny-by-default). */
export function defaultPermissionsManifest(): PermissionsManifest {
  return {
    calendar: 'none',
    files: 'none',
    actions: 'none',
    spending: { perTransaction: 0, perDay: 0, perConnection: 0 },
    informationBoundaries: [],
    customCategories: [],
  };
}
```

Also export a `validateManifest(m: PermissionsManifest): string[]` function that returns validation errors:
- If `files === 'specific_folders'` and `allowedFolders` is empty/undefined, error.
- If `actions === 'scoped'` and `actionScopes` is empty/undefined, error.
- If spending caps are negative, error.

**autonomy/permissions-manifest.test.ts (NEW):**
- Test defaultPermissionsManifest returns deny-all values.
- Test validateManifest passes for valid manifests.
- Test validateManifest catches specific_folders with no folders.
- Test validateManifest catches scoped actions with no scopes.
- Test validateManifest catches negative spending caps.

**autonomy/policy-evaluator.ts (NEW):**

Define the PolicyEvaluator interface. The actual LLM call is injected -- this keeps the skill testable without an LLM.

```typescript
export interface PolicyDecision {
  action: 'allow' | 'deny' | 'escalate';
  confidence: 'high' | 'medium' | 'low';
  reasoning: string;
}

/**
 * PolicyEvaluator is an INTERFACE for LLM-evaluated policy decisions.
 * The actual implementation is injected by the OpenClaw agent runtime.
 * Tests use a mock evaluator.
 */
export interface PolicyEvaluator {
  /**
   * Evaluate a message against a human-written natural language policy.
   * Used for Auto-respond autonomy level.
   */
  evaluatePolicy(params: {
    policy: string;
    messageBody: string;
    senderAddress: string;
    connectionNickname: string;
  }): Promise<PolicyDecision>;

  /**
   * Check whether content violates information boundaries.
   * Used for any autonomy level when boundaries are configured.
   * Per locked decision: uncertain outcomes -> block + escalate to human.
   */
  checkInformationBoundary(params: {
    boundaries: string[];
    content: string;
  }): Promise<PolicyDecision>;
}
```

Also create a `NoOpPolicyEvaluator` class that implements the interface with safe defaults:
- `evaluatePolicy()` returns `{ action: 'escalate', confidence: 'low', reasoning: 'No LLM available -- escalating to human' }`.
- `checkInformationBoundary()` returns `{ action: 'escalate', confidence: 'low', reasoning: 'No LLM available -- escalating to human' }`.

This NoOpPolicyEvaluator is the safe fallback per research pitfall 5 (LLM unavailability). Export it.

**autonomy/policy-evaluator.test.ts (NEW):**
- Test NoOpPolicyEvaluator.evaluatePolicy returns escalate.
- Test NoOpPolicyEvaluator.checkInformationBoundary returns escalate.

**autonomy/permissions-enforcer.ts (NEW):**

Create a `PermissionsEnforcer` class that checks a message against the connection's permissions manifest. This runs BEFORE autonomy routing -- it gates what gets through at all.

Constructor: `(connectionStore: ConnectionStore, policyEvaluator: PolicyEvaluator)`.

```typescript
export interface EnforcementResult {
  allowed: boolean;
  reason?: string;             // Why denied
  violationType?: string;      // 'permission_violation' | 'information_boundary' | 'spending_exceeded'
  escalateToHuman?: boolean;   // True if uncertain and needs human decision
}
```

Method: `async check(messageBody: string, connectionAddress: string): Promise<EnforcementResult>`

Logic:
1. Get connection from store. If no connection or not active, return `{ allowed: false, reason: 'unknown sender' }`.
2. Get the `permissionsManifest` from the connection. If undefined, treat as deny-all (create default manifest).
3. **Structural checks** (no LLM needed):
   - Parse the message body for action requests. Since messages are plaintext strings at this level, structural enforcement checks whether the manifest has any permissions set beyond 'none'. If all core categories are 'none' and there are no custom categories, the manifest is effectively deny-all.
   - For now, structural enforcement is a guard: if `calendar === 'none' && files === 'none' && actions === 'none' && spending caps are all 0`, and the message contains content that looks like it's requesting action (this is a soft check -- real enforcement happens at the application layer where message types are structured). The structural check ensures a deny-all manifest blocks everything.
   - NOTE: In v1, the structural check is intentionally permissive for plain text messages. The core purpose is to block action requests when the manifest denies them. Since Pinch messages are encrypted plaintext (not structured action types yet), the structural check focuses on the information boundary aspect. Future phases can add structured action types.
4. **Information boundary check** (LLM needed):
   - If `informationBoundaries` is non-empty, call `policyEvaluator.checkInformationBoundary()` with the boundaries and message body.
   - If result is `deny` or `escalate`, return `{ allowed: false, reason: result.reasoning, violationType: 'information_boundary', escalateToHuman: result.action === 'escalate' }`.
   - Per locked decision: "When the LLM is uncertain whether content violates an information boundary, block the message and escalate to the human for a decision."
5. **Custom category check** (LLM needed):
   - For each custom category where `allowed === false`, the message should not match the category description. Since this requires LLM interpretation, call `policyEvaluator.checkInformationBoundary()` with the category description as a boundary.
6. If all checks pass, return `{ allowed: true }`.

Wrap all LLM calls in try/catch. On failure, return `{ allowed: false, reason: 'Policy evaluation unavailable -- escalating to human', escalateToHuman: true }`. This is the safe default per research pitfall 5.

**autonomy/permissions-enforcer.test.ts (NEW):**

Create a `MockPolicyEvaluator` for tests that returns configurable decisions.

Tests:
- Test unknown connection -> denied.
- Test deny-all manifest with no boundaries -> allowed (plain text passes structural check; boundaries are what gate content).
- Test information boundary with LLM deny -> denied with correct violationType.
- Test information boundary with LLM escalate -> denied with escalateToHuman true.
- Test information boundary with LLM allow -> allowed.
- Test LLM failure -> escalate to human (safe default).
- Test custom category with allowed=false triggers boundary check.

**connection-store.ts changes:**

1. Import `PermissionsManifest` and `defaultPermissionsManifest` from `"./autonomy/permissions-manifest.js"`.
2. Add `permissionsManifest?: PermissionsManifest` field to the `Connection` interface.
3. In `addConnection()`, assign `defaultPermissionsManifest()` when no manifest is provided. This enforces deny-by-default for new connections per locked decision.
4. Update `updateConnection()` `Pick` type to include `permissionsManifest`.
5. Add convenience method: `setPermissions(peerAddress: string, manifest: PermissionsManifest): Connection` -- validates the manifest (using `validateManifest()`), updates the connection, returns updated connection.
  </action>
  <verify>
    <automated>cd /Users/riecekeck/Coding/Pinch && npx vitest run skill/src/autonomy/permissions-manifest.test.ts skill/src/autonomy/permissions-enforcer.test.ts skill/src/autonomy/policy-evaluator.test.ts skill/src/connection-store.test.ts --reporter=verbose 2>&1 | tail -40</automated>
    <manual>Verify defaultPermissionsManifest() returns all-deny values</manual>
  </verify>
  <done>PermissionsManifest type defines all domain-specific capability tiers, defaultPermissionsManifest() returns deny-all, PermissionsEnforcer gates content before routing with information boundary LLM checks, PolicyEvaluator interface enables LLM injection, NoOpPolicyEvaluator provides safe fallback, new connections get deny-all manifest. All tests pass.</done>
</task>

<task type="auto">
  <name>Task 2: Create pinch-permissions tool and update exports</name>
  <files>
    skill/src/tools/pinch-permissions.ts
    skill/src/tools/pinch-permissions.test.ts
    skill/src/index.ts
    skill/package.json
  </files>
  <action>
**tools/pinch-permissions.ts (NEW):**

Create following the existing tool pattern (see pinch-send.ts, pinch-autonomy.ts from Plan 01):
- Self-executable TypeScript module with `process.argv[1]` check.
- `parseArgs(args: string[])` exported for testability.
- `run()` function: bootstrap -> parse args -> configure permissions -> JSON output -> shutdown.

CLI interface for viewing current permissions:
```
pinch-permissions --address <pinch:address> --show
```

CLI interface for setting permissions:
```
pinch-permissions --address <pinch:address> --calendar <none|free_busy_only|full_details|propose_and_book> --files <none|specific_folders|everything> [--folders "folder1,folder2"] --actions <none|scoped|full> [--scopes "scope1,scope2"] --spending-per-tx <number> --spending-per-day <number> --spending-per-connection <number>
```

CLI interface for adding/removing information boundaries:
```
pinch-permissions --address <pinch:address> --add-boundary "never share my financials"
pinch-permissions --address <pinch:address> --remove-boundary 0
```

CLI interface for adding/removing custom categories:
```
pinch-permissions --address <pinch:address> --add-category "Recruitment" --category-description "Discussing job offers" --category-allowed false
pinch-permissions --address <pinch:address> --remove-category "Recruitment"
```

All modifications use `connectionStore.setPermissions()` from Task 1 changes.

Output JSON for --show: `{ "address": "...", "permissions": { ...manifest } }`
Output JSON for modifications: `{ "address": "...", "updated": { ...manifest } }`
Error JSON: `{ "error": "..." }`

**tools/pinch-permissions.test.ts (NEW):**
- Test parseArgs with --show.
- Test parseArgs with --calendar, --files, --actions.
- Test parseArgs with --add-boundary.
- Test parseArgs with --add-category.
- Test parseArgs with missing --address.

**index.ts changes:**
- Export `PermissionsManifest`, `defaultPermissionsManifest`, `validateManifest` from `"./autonomy/permissions-manifest.js"`.
- Export `PermissionsEnforcer`, `EnforcementResult` from `"./autonomy/permissions-enforcer.js"`.
- Export `PolicyEvaluator`, `PolicyDecision`, `NoOpPolicyEvaluator` from `"./autonomy/policy-evaluator.js"`.

**package.json changes:**
- Add `"pinch-permissions": "./dist/tools/pinch-permissions.js"` to the `bin` field.
  </action>
  <verify>
    <automated>cd /Users/riecekeck/Coding/Pinch && npx vitest run skill/src/tools/pinch-permissions.test.ts --reporter=verbose 2>&1 | tail -20</automated>
    <manual>Verify index.ts exports all new autonomy module types</manual>
  </verify>
  <done>pinch-permissions tool allows viewing and modifying permissions manifests with domain-specific capability tiers. All new types exported from index.ts. bin entry added to package.json. All tests pass.</done>
</task>

</tasks>

<verification>
Run all tests to verify no regressions:
```bash
cd /Users/riecekeck/Coding/Pinch && npx vitest run --reporter=verbose 2>&1 | tail -50
```

Verify deny-by-default manifest:
```bash
grep -n "defaultPermissionsManifest" skill/src/autonomy/permissions-manifest.ts skill/src/connection-store.ts
```

Verify enforcement pipeline ordering:
```bash
grep -n "check\|enforce" skill/src/autonomy/permissions-enforcer.ts
```
</verification>

<success_criteria>
- PermissionsManifest type has all domain-specific capability tiers from CONTEXT.md
- defaultPermissionsManifest() returns deny-all (calendar: none, files: none, actions: none, spending: all zeros)
- New connections automatically get deny-all manifest
- PermissionsEnforcer checks manifest BEFORE content reaches autonomy routing
- Information boundaries delegate to PolicyEvaluator for LLM evaluation
- Uncertain boundary outcomes block + escalate per locked decision
- LLM unavailability falls back to escalate (safe default)
- PolicyEvaluator is an injectable interface (testable without LLM)
- NoOpPolicyEvaluator returns escalate for all checks
- pinch-permissions tool configures manifests via CLI
- All new and existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/05-full-autonomy-and-permissions/05-02-SUMMARY.md`
</output>
