---
phase: 01-foundation-and-crypto-primitives
plan: 02
type: tdd
wave: 2
depends_on:
  - "01-01"
files_modified:
  - testdata/crypto_vectors.json
  - testdata/identity_vectors.json
  - relay/internal/crypto/crypto.go
  - relay/internal/crypto/crypto_test.go
  - relay/internal/identity/identity.go
  - relay/internal/identity/identity_test.go
  - skill/src/crypto.ts
  - skill/src/crypto.test.ts
  - skill/src/identity.ts
  - skill/src/identity.test.ts
  - skill/package.json
  - relay/go.mod
  - relay/go.sum
  - tests/cross-language/run.sh
  - tests/cross-language/go_encrypt/main.go
  - tests/cross-language/ts_decrypt/decrypt.ts
  - tests/cross-language/ts_encrypt/encrypt.ts
  - tests/cross-language/go_decrypt/main.go
autonomous: true
requirements:
  - IDNT-01
  - IDNT-02
  - IDNT-03
  - CRYP-02
  - CRYP-03
  - CRYP-04

must_haves:
  truths:
    - "Agent generates an Ed25519 keypair, persists it to disk, reloads it, and derives the same pinch: address both times"
    - "Both Go and TypeScript produce the same pinch: address from the same Ed25519 public key"
    - "Both Go and TypeScript produce the same X25519 keys from the same Ed25519 keypair"
    - "Go encrypts with NaCl box using X25519 keys and a random 24-byte nonce; TypeScript decrypts successfully"
    - "TypeScript encrypts with NaCl box; Go decrypts successfully"
    - "Encrypting the same plaintext twice produces different ciphertexts (nonce uniqueness)"
    - "Cross-language crypto roundtrip tests pass in CI"
  artifacts:
    - path: "relay/internal/crypto/crypto.go"
      provides: "Go NaCl box encrypt/decrypt + Ed25519-to-X25519 conversion"
      exports: ["Encrypt", "Decrypt", "Ed25519PublicToX25519", "Ed25519PrivateToX25519"]
    - path: "relay/internal/identity/identity.go"
      provides: "Go address generation and validation from Ed25519 public keys"
      exports: ["GenerateAddress", "ValidateAddress", "ParseAddress"]
    - path: "skill/src/crypto.ts"
      provides: "TypeScript NaCl box encrypt/decrypt + Ed25519-to-X25519 conversion"
      exports: ["encrypt", "decrypt", "ed25519PubToX25519", "ed25519PrivToX25519"]
    - path: "skill/src/identity.ts"
      provides: "TypeScript keypair generation, persistence, address derivation"
      exports: ["generateKeypair", "loadKeypair", "saveKeypair", "generateAddress", "validateAddress"]
    - path: "testdata/crypto_vectors.json"
      provides: "Shared cross-language crypto test vectors"
      contains: "ed25519_seed"
    - path: "testdata/identity_vectors.json"
      provides: "Shared cross-language identity/address test vectors"
      contains: "pinch:"
    - path: "tests/cross-language/run.sh"
      provides: "CI script for live cross-process crypto roundtrip"
      min_lines: 20
  key_links:
    - from: "relay/internal/crypto/crypto.go"
      to: "testdata/crypto_vectors.json"
      via: "shared test vectors loaded in crypto_test.go"
      pattern: "crypto_vectors\\.json"
    - from: "skill/src/crypto.test.ts"
      to: "testdata/crypto_vectors.json"
      via: "shared test vectors loaded in test"
      pattern: "crypto_vectors\\.json"
    - from: "relay/internal/identity/identity.go"
      to: "relay/internal/crypto/crypto.go"
      via: "imports X25519 conversion for address derivation"
      pattern: "crypto\\.Ed25519"
    - from: "skill/src/identity.ts"
      to: "skill/src/crypto.ts"
      via: "imports crypto functions for key conversion"
      pattern: "from.*crypto"
---

<objective>
Implement Ed25519 identity management (keypair generation, persistence, address format) and NaCl box encryption in both Go and TypeScript, with shared test vectors and cross-language roundtrip tests proving interoperability.

Purpose: Establish the cryptographic primitives that every subsequent phase depends on -- identity, addressing, and encryption. Cross-language test vectors are the ONLY way to guarantee Go and TypeScript produce compatible outputs.
Output: Working crypto modules in both languages, shared test vectors, and a CI-ready cross-language test script.
</objective>

<execution_context>
@/Users/riecekeck/.claude/get-shit-done/workflows/execute-plan.md
@/Users/riecekeck/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-and-crypto-primitives/01-RESEARCH.md
@.planning/phases/01-foundation-and-crypto-primitives/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement identity and crypto modules with shared test vectors (TDD)</name>
  <files>
    testdata/crypto_vectors.json
    testdata/identity_vectors.json
    relay/internal/crypto/crypto.go
    relay/internal/crypto/crypto_test.go
    relay/internal/identity/identity.go
    relay/internal/identity/identity_test.go
    skill/src/crypto.ts
    skill/src/crypto.test.ts
    skill/src/identity.ts
    skill/src/identity.test.ts
    skill/package.json
    relay/go.mod
    relay/go.sum
  </files>
  <action>
    This is a TDD task. Follow RED -> GREEN -> REFACTOR for each component.

    **Step 0: Install dependencies**
    - Go: `cd relay && go get golang.org/x/crypto/nacl/box filippo.io/edwards25519 github.com/mr-tron/base58`
    - TypeScript: `cd skill && pnpm add libsodium-wrappers-sumo@0.8.0 bs58@^6`
    - TypeScript devDeps: `pnpm add -D @types/libsodium-wrappers-sumo` (if separate types package exists, otherwise types ship with sumo)

    **Step 1: Generate shared test vectors from Go**

    Create a Go test helper (or a small generator program) that produces `testdata/crypto_vectors.json` and `testdata/identity_vectors.json`:

    `identity_vectors.json` -- 3 vectors, each with:
    - `ed25519_seed` (hex, 32 bytes) -- use hardcoded deterministic seeds
    - `ed25519_public_key` (hex, 32 bytes)
    - `ed25519_private_key` (hex, 64 bytes)
    - `x25519_public_key` (hex, 32 bytes)
    - `x25519_private_key` (hex, 32 bytes)
    - `address` (string, `pinch:<base58>@test.relay.example.com`)

    `crypto_vectors.json` -- 3 vectors, each with:
    - `description` (string)
    - `sender_ed25519_seed` (hex)
    - `recipient_ed25519_seed` (hex)
    - `sender_x25519_pub` (hex), `sender_x25519_priv` (hex)
    - `recipient_x25519_pub` (hex), `recipient_x25519_priv` (hex)
    - `nonce` (hex, 24 bytes) -- hardcoded for test vector reproducibility
    - `plaintext` (hex)
    - `ciphertext` (hex) -- nonce prepended to encrypted output

    **Step 2: RED -- Write failing tests first**

    Go tests (`relay/internal/crypto/crypto_test.go`):
    - TestEd25519PublicToX25519: load identity vectors, convert, compare against expected X25519 public keys
    - TestEd25519PrivateToX25519: load identity vectors, convert, compare against expected X25519 private keys
    - TestEncrypt: use crypto vectors, encrypt with known nonce (test helper that accepts nonce), compare against expected ciphertext
    - TestDecrypt: use crypto vectors, decrypt known ciphertext, compare against expected plaintext
    - TestEncryptRandomNonce: encrypt same plaintext twice, verify different ciphertexts
    - TestNoncePrependedToCiphertext: encrypt, verify first 24 bytes of output match the nonce

    Go tests (`relay/internal/identity/identity_test.go`):
    - TestGenerateAddress: load identity vectors, generate address from public key, compare against expected
    - TestValidateAddress: validate known-good addresses succeed, tampered addresses fail
    - TestParseAddress: parse `pinch:<base58>@host` into public key + host components

    TypeScript tests (`skill/src/crypto.test.ts`):
    - Same test cases as Go, loading from same JSON vector files
    - IMPORTANT: `await sodium.ready` in beforeAll()
    - Test that ed25519PubToX25519 matches vector expected values
    - Test that ed25519PrivToX25519 matches vector expected values
    - Test encrypt with known nonce matches expected ciphertext
    - Test decrypt of known ciphertext produces expected plaintext
    - Test random nonce produces different ciphertexts for same plaintext

    TypeScript tests (`skill/src/identity.test.ts`):
    - TestGenerateKeypair: generates a keypair, verify public key is 32 bytes, private key is 64 bytes
    - TestSaveAndLoadKeypair: save to temp file, reload, verify same keypair and same address
    - TestGenerateAddress: use identity vectors, verify address matches
    - TestValidateAddress: valid addresses pass, tampered ones fail

    Run all tests -- they should FAIL (functions don't exist yet).

    **Step 3: GREEN -- Implement to pass**

    **Go crypto module** (`relay/internal/crypto/crypto.go`):
    - `Ed25519PublicToX25519(pub ed25519.PublicKey) ([]byte, error)` -- use `filippo.io/edwards25519` Point.SetBytes().BytesMontgomery()
    - `Ed25519PrivateToX25519(priv ed25519.PrivateKey) []byte` -- SHA-512 of seed, clamp per RFC 7748 (clear bits 0-2 of byte 0, clear bit 7 and set bit 6 of byte 31)
    - `Encrypt(plaintext []byte, recipientX25519Pub, senderX25519Priv *[32]byte) ([]byte, error)` -- random 24-byte nonce from crypto/rand, box.Seal, prepend nonce
    - `Decrypt(sealed []byte, senderX25519Pub, recipientX25519Priv *[32]byte) ([]byte, error)` -- extract nonce from first 24 bytes, box.Open
    - Internal `encryptWithNonce` variant for test vector validation (accepts nonce parameter)

    **Go identity module** (`relay/internal/identity/identity.go`):
    - `GenerateAddress(pubKey ed25519.PublicKey, relayHost string) string` -- SHA-256(pubKey)[0:4] checksum, base58(pubKey + checksum), format `pinch:<base58>@<host>`
    - `ValidateAddress(addr string) (ed25519.PublicKey, string, error)` -- parse, base58 decode, split 32+4, verify checksum
    - `ParseAddress(addr string) (payload string, host string, error)` -- regex parse `^pinch:([1-9A-HJ-NP-Za-km-z]+)@(.+)$`

    **TypeScript crypto module** (`skill/src/crypto.ts`):
    - `ed25519PubToX25519(pubKey: Uint8Array): Uint8Array` -- `sodium.crypto_sign_ed25519_pk_to_curve25519(pubKey)` (MUST use sumo variant)
    - `ed25519PrivToX25519(privKey: Uint8Array): Uint8Array` -- `sodium.crypto_sign_ed25519_sk_to_curve25519(privKey)`
    - `encrypt(plaintext: Uint8Array, recipientX25519Pub: Uint8Array, senderX25519Priv: Uint8Array): Uint8Array` -- random nonce via `sodium.randombytes_buf(24)`, `sodium.crypto_box_easy()`, prepend nonce
    - `decrypt(sealed: Uint8Array, senderX25519Pub: Uint8Array, recipientX25519Priv: Uint8Array): Uint8Array` -- extract nonce (first 24 bytes), `sodium.crypto_box_open_easy()`
    - `ensureSodiumReady()` -- singleton init wrapper around `await sodium.ready`

    **TypeScript identity module** (`skill/src/identity.ts`):
    - `generateKeypair(): Promise<{publicKey, privateKey}>` -- `sodium.crypto_sign_keypair()` (after ensureSodiumReady)
    - `saveKeypair(keypair, path): Promise<void>` -- write JSON `{version: 1, public_key: base64, private_key: base64, created_at: ISO}`
    - `loadKeypair(path): Promise<{publicKey, privateKey}>` -- read JSON, decode base64, return Uint8Arrays
    - `generateAddress(pubKey: Uint8Array, relayHost: string): string` -- SHA-256(pubKey)[0:4] checksum, bs58.encode(concat(pubKey, checksum)), `pinch:<base58>@<host>`
    - `validateAddress(addr: string): {pubKey: Uint8Array, host: string}` -- parse, decode, verify checksum

    Run all tests -- they should now PASS.

    **Step 4: REFACTOR** -- Clean up if needed, ensure consistent error handling, add JSDoc/Go doc comments.
  </action>
  <verify>
    <automated>cd /Users/riecekeck/Coding/Pinch && go test ./relay/internal/... -v && pnpm -C skill test</automated>
  </verify>
  <done>All Go and TypeScript tests pass against shared test vectors. Ed25519-to-X25519 conversion produces identical keys in both languages. NaCl box encrypt/decrypt works in both languages. Address generation produces identical addresses from same public keys. Keypair persists and reloads in TypeScript with same address.</done>
</task>

<task type="auto">
  <name>Task 2: Cross-language live crypto roundtrip integration tests</name>
  <files>
    tests/cross-language/run.sh
    tests/cross-language/go_encrypt/main.go
    tests/cross-language/go_decrypt/main.go
    tests/cross-language/ts_decrypt/decrypt.ts
    tests/cross-language/ts_encrypt/encrypt.ts
    .github/workflows/ci.yml
  </files>
  <action>
    Create a live cross-process integration test that runs in CI per user decision (not just shared vectors -- actual process-to-process handoff).

    **Go encrypt program** (`tests/cross-language/go_encrypt/main.go`):
    - Takes a JSON input from stdin: `{"ed25519_seed_sender": "hex", "ed25519_seed_recipient": "hex", "plaintext": "hex"}`
    - Generates Ed25519 keypairs from seeds, converts to X25519
    - Encrypts plaintext with NaCl box (random nonce)
    - Outputs JSON to stdout: `{"sealed": "hex"}` (nonce prepended to ciphertext)

    **TypeScript decrypt program** (`tests/cross-language/ts_decrypt/decrypt.ts`):
    - Takes JSON from stdin: `{"ed25519_seed_sender": "hex", "ed25519_seed_recipient": "hex", "sealed": "hex"}`
    - Generates keypairs from seeds (same seeds = same keys), converts to X25519
    - Decrypts sealed bytes
    - Outputs JSON to stdout: `{"plaintext": "hex"}`

    **TypeScript encrypt program** (`tests/cross-language/ts_encrypt/encrypt.ts`):
    - Same input format as Go encrypt
    - Outputs `{"sealed": "hex"}`

    **Go decrypt program** (`tests/cross-language/go_decrypt/main.go`):
    - Same input format as TypeScript decrypt
    - Outputs `{"plaintext": "hex"}`

    **Integration test script** (`tests/cross-language/run.sh`):
    - #!/bin/bash, set -euo pipefail
    - Define test cases (sender seed, recipient seed, plaintext) inline
    - For each test case:
      1. Pipe input to Go encrypt -> capture sealed output
      2. Pipe sealed + seeds to TypeScript decrypt -> verify plaintext matches
      3. Pipe input to TypeScript encrypt -> capture sealed output
      4. Pipe sealed + seeds to Go decrypt -> verify plaintext matches
    - Print PASS/FAIL for each direction
    - Exit 0 if all pass, 1 if any fail

    **CI update** (`.github/workflows/ci.yml`):
    - Add a third job `cross-language` that depends on both Go and TypeScript jobs
    - Sets up both Go and Node.js
    - Runs `buf generate` (to ensure gen code is fresh)
    - Runs `bash tests/cross-language/run.sh`

    The Go programs should import from `relay/internal/crypto` (not duplicate the crypto logic). The TypeScript programs should import from `skill/src/crypto.ts`.

    Make the TS scripts executable via `npx tsx` (add tsx as a devDep in skill/ if not present).
  </action>
  <verify>
    <automated>cd /Users/riecekeck/Coding/Pinch && bash tests/cross-language/run.sh</automated>
  </verify>
  <done>Go encrypts -> TypeScript decrypts successfully. TypeScript encrypts -> Go decrypts successfully. Both directions pass in the integration test script. CI workflow includes the cross-language job.</done>
</task>

</tasks>

<verification>
1. `go test ./relay/internal/... -v` -- all crypto and identity tests pass
2. `pnpm -C skill test` -- all crypto and identity tests pass
3. Both Go and TypeScript produce identical X25519 keys from same Ed25519 seed (verified via shared vectors)
4. Both produce identical `pinch:` addresses from same public key (verified via shared vectors)
5. `bash tests/cross-language/run.sh` -- Go->TS and TS->Go roundtrips pass
6. Keypair save/load produces same address on reload
7. Encrypting same plaintext twice produces different ciphertexts
</verification>

<success_criteria>
- Ed25519 keypairs generate, persist, and reload with the same derived pinch: address
- Cross-language crypto is provably compatible via shared test vectors AND live integration
- NaCl box encryption uses random 24-byte nonces prepended to ciphertext
- Address format matches spec: pinch:<base58(pubkey+checksum)>@<host>
- All tests pass in both languages
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-and-crypto-primitives/01-02-SUMMARY.md`
</output>
