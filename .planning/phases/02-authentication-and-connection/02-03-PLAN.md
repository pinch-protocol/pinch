---
phase: 02-authentication-and-connection
plan: 03
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - skill/src/auth.ts
  - skill/src/auth.test.ts
  - skill/src/relay-client.ts
  - skill/src/relay-client.test.ts
  - skill/src/connection-store.ts
  - skill/src/connection-store.test.ts
autonomous: true
requirements: [AUTO-01, AUTO-02, CONN-01, CONN-02]

must_haves:
  truths:
    - "TypeScript agent signs the relay's nonce challenge with its Ed25519 private key and receives its assigned pinch: address back"
    - "RelayClient performs auth handshake automatically on connect -- no more ?address= query parameter"
    - "Connection store persists all connections as JSON with states: active, pending_outbound, pending_inbound, blocked, revoked"
    - "New connections default to full_manual autonomy level; upgrading to full_auto requires explicit confirmation flag (data-layer gate; UX deferred to Phase 3)"
    - "Connection entries include: peerAddress, peerPublicKey, state, nickname, autonomyLevel, shortMessage, timestamps"
  artifacts:
    - path: "skill/src/auth.ts"
      provides: "Challenge signing for relay auth handshake"
      exports: ["signChallenge"]
    - path: "skill/src/relay-client.ts"
      provides: "Updated RelayClient with auth handshake on connect"
      contains: "signChallenge"
    - path: "skill/src/connection-store.ts"
      provides: "JSON-backed connection state persistence with all CRUD operations"
      exports: ["ConnectionStore", "Connection", "ConnectionState", "AutonomyLevel"]
  key_links:
    - from: "skill/src/relay-client.ts"
      to: "skill/src/auth.ts"
      via: "connect() calls signChallenge during auth handshake"
      pattern: "signChallenge"
    - from: "skill/src/relay-client.ts"
      to: "gen/ts/pinch/v1/envelope_pb.ts"
      via: "Deserializes AuthChallenge, serializes AuthResponse using protobuf"
      pattern: "AuthChallenge|AuthResponse|Envelope"
    - from: "skill/src/connection-store.ts"
      to: "node:fs/promises"
      via: "readFile/writeFile for JSON persistence"
      pattern: "readFile|writeFile"
---

<objective>
Implement TypeScript auth handshake (challenge signing + RelayClient rewrite) and the agent-side connection store with autonomy levels, so the agent can authenticate to the relay cryptographically and manage its connection state locally.

Purpose: Agent side of the auth handshake completes the cryptographic authentication loop. The connection store is the foundation for all connection lifecycle operations (request, approve, reject, block, revoke) and autonomy control.
Output: Auth module, updated RelayClient with auth handshake, JSON-backed ConnectionStore with all states and autonomy.
</objective>

<execution_context>
@/Users/riecekeck/.claude/get-shit-done/workflows/execute-plan.md
@/Users/riecekeck/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-authentication-and-connection/02-RESEARCH.md
@.planning/phases/02-authentication-and-connection/02-01-SUMMARY.md
@skill/src/relay-client.ts
@skill/src/identity.ts
@skill/src/crypto.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement TypeScript auth module and rewrite RelayClient connect with auth handshake</name>
  <files>
    skill/src/auth.ts
    skill/src/auth.test.ts
    skill/src/relay-client.ts
    skill/src/relay-client.test.ts
  </files>
  <action>
    **Create `skill/src/auth.ts`:**

    Import `sodium` from `libsodium-wrappers-sumo` and `ensureSodiumReady` from `./crypto.js`.

    Export function:
    - `signChallenge(nonce: Uint8Array, privateKey: Uint8Array): Uint8Array` -- Signs the nonce using `sodium.crypto_sign_detached(nonce, privateKey)`. Returns 64-byte signature. Call `ensureSodiumReady()` if needed (make it async, or document that caller must ensure sodium is ready).

    **Create `skill/src/auth.test.ts`:**

    Test cases:
    - signChallenge produces a 64-byte signature
    - Signature verifies with `sodium.crypto_sign_verify_detached`
    - Different nonces produce different signatures
    - Wrong key produces a signature that doesn't verify

    **Rewrite `skill/src/relay-client.ts`:**

    The RelayClient constructor currently takes `(relayUrl, address, options)`. Change it to accept a `Keypair` (from `./identity.ts`) instead of a plain address string, since the auth handshake needs the private key for signing.

    New constructor signature:
    ```typescript
    constructor(
        relayUrl: string,
        keypair: Keypair,
        relayHost: string,
        options?: RelayClientOptions
    )
    ```

    The `address` is no longer provided by the caller -- it's assigned by the relay during auth.

    Add an `assignedAddress` property (string | null, populated after successful auth).

    Rewrite `connect()`:
    1. Open WebSocket to `${this.relayUrl}/ws` (no more `?address=` query param)
    2. Wait for WebSocket open
    3. Wait for first binary message from relay -- deserialize as protobuf `Envelope`, expect `auth_challenge` payload
    4. Extract nonce from `AuthChallenge`
    5. Sign nonce: `signChallenge(nonce, this.keypair.privateKey)`
    6. Serialize `AuthResponse` envelope (with signature and public key) and send
    7. Wait for next binary message -- deserialize as `Envelope`, expect `auth_result` payload
    8. If `AuthResult.success` is false, throw an error with the error_message
    9. Store `AuthResult.assigned_address` as `this.assignedAddress`
    10. Start heartbeat (same as before)
    11. Resolve the connect promise

    For protobuf serialization, use `@bufbuild/protobuf` with the generated types from `@pinch/proto` (`gen/ts/pinch/v1/envelope_pb.ts`). Use `create()` to build messages and `toBinary()`/`fromBinary()` for serialization.

    **Update `skill/src/relay-client.test.ts`:**

    Tests now need to generate keypairs for the RelayClient constructor. Update existing tests to use a keypair. The integration tests that spawn the Go relay will now exercise the full auth handshake.

    Key test updates:
    - Generate a keypair with `generateKeypair()` from identity module
    - Pass keypair to RelayClient constructor
    - Verify `assignedAddress` is populated after connect
    - Verify auth failure with invalid keypair/signature (if relay rejects, connect should throw)

    NOTE: If the Go relay from Plan 01 is not yet available (this plan runs in Wave 2 parallel with Plan 02), the integration tests that spawn the real relay binary should still work since Plan 01 (Wave 1) will have completed first and the relay binary will have the auth handshake.
  </action>
  <verify>
    <automated>cd /Users/riecekeck/Coding/Pinch/skill && pnpm test -- --reporter=verbose 2>&1 | head -80</automated>
    <manual>Verify RelayClient no longer uses ?address= query param and requires a Keypair</manual>
  </verify>
  <done>Auth module signs challenges with Ed25519. RelayClient performs full auth handshake on connect (receive challenge, sign, send response, receive result). assignedAddress populated from relay's AuthResult. No more ?address= query parameter. Auth and integration tests pass.</done>
</task>

<task type="auto">
  <name>Task 2: Implement JSON-backed connection store with autonomy levels</name>
  <files>
    skill/src/connection-store.ts
    skill/src/connection-store.test.ts
  </files>
  <action>
    **Create `skill/src/connection-store.ts`:**

    Define types:
    ```typescript
    type ConnectionState = "active" | "pending_outbound" | "pending_inbound" | "blocked" | "revoked";
    type AutonomyLevel = "full_manual" | "full_auto";

    interface Connection {
        peerAddress: string;        // pinch:<hash>@<relay>
        peerPublicKey: string;      // base64-encoded Ed25519 pubkey (empty for pending_outbound until accepted)
        state: ConnectionState;
        nickname: string;           // local-only, user-assigned, default empty string
        autonomyLevel: AutonomyLevel;
        shortMessage?: string;      // from connection request (max 280 chars)
        createdAt: string;          // ISO timestamp
        lastActivity: string;       // ISO timestamp
        expiresAt?: string;         // for pending requests, ISO timestamp (7-day TTL default)
    }

    interface StoreData {
        version: number;
        connections: Record<string, Connection>; // keyed by peerAddress
    }
    ```

    Implement `ConnectionStore` class:
    - `constructor(path: string)` -- Path to JSON file
    - `async load(): Promise<void>` -- Read JSON file, parse. If file doesn't exist, initialize empty store.
    - `async save(): Promise<void>` -- Create parent directory if needed (`mkdir` with `recursive: true`), write JSON with 2-space indent.
    - `getConnection(peerAddress: string): Connection | undefined`
    - `listConnections(filter?: { state?: ConnectionState }): Connection[]` -- List all, optionally filtered by state. Sort by state priority (active > pending_inbound > pending_outbound > revoked > blocked), then by lastActivity descending within each group (per discretion decision).
    - `addConnection(conn: Omit<Connection, "createdAt" | "lastActivity">): Connection` -- Sets createdAt and lastActivity to now. Enforces default autonomyLevel = "full_manual" (per AUTO-02). Validates shortMessage length <= 280 chars (per discretion decision). Returns the created connection.
    - `updateConnection(peerAddress: string, updates: Partial<Pick<Connection, "state" | "nickname" | "autonomyLevel" | "peerPublicKey" | "lastActivity">>): Connection` -- Updates specified fields, updates lastActivity to now.
    - `setNickname(peerAddress: string, nickname: string): Connection` -- Convenience method for local-only nicknames.
    - `setAutonomy(peerAddress: string, level: AutonomyLevel, opts?: { confirmed?: boolean }): Connection` -- Changes autonomy level. Per locked decision: downgrade from full_auto to full_manual takes effect immediately (no gate). However, upgrading from full_manual to full_auto REQUIRES `opts.confirmed === true` -- if the caller attempts a full_manual -> full_auto upgrade without `confirmed: true`, throw an error with message "Upgrading to Full Auto requires explicit confirmation". This enforces the locked user decision ("Upgrading from Full Manual to Full Auto requires a confirmation step with a clear warning") at the data layer. The actual confirmation UX (presenting the warning "This agent will process messages without your approval" and collecting the user's approval) is deferred to Phase 3 skill integration, which will call `setAutonomy(addr, "full_auto", { confirmed: true })` after the human confirms. The store just records the change; autonomy enforcement at the message processing layer is also Phase 3+.
    - `expirePendingRequests(): string[]` -- Finds all pending connections where `expiresAt` is in the past, marks them as "revoked" (expired pending = cleaned up). Returns list of expired peerAddresses. TTL default: 7 days (604800 seconds) per discretion decision.

    Export all types and the class.

    **Create `skill/src/connection-store.test.ts`:**

    Test cases (use `fs.mkdtemp` for temp directory):
    - Load from non-existent file creates empty store
    - addConnection sets defaults (full_manual autonomy, timestamps)
    - addConnection rejects shortMessage > 280 chars
    - getConnection returns correct connection
    - listConnections returns all connections
    - listConnections with state filter works
    - listConnections sorts by state priority then lastActivity
    - updateConnection changes specific fields and updates lastActivity
    - setNickname updates nickname only
    - setAutonomy changes autonomy level (full_auto -> full_manual, no gate)
    - setAutonomy rejects full_manual -> full_auto upgrade without confirmed: true
    - setAutonomy allows full_manual -> full_auto upgrade with confirmed: true
    - save/load roundtrip preserves all fields
    - expirePendingRequests marks expired connections as revoked
    - expirePendingRequests ignores non-expired and non-pending connections
    - Connection states: can transition active -> blocked, active -> revoked, blocked -> active (unblock is reversible)
  </action>
  <verify>
    <automated>cd /Users/riecekeck/Coding/Pinch/skill && pnpm test -- --reporter=verbose 2>&1 | head -80</automated>
  </verify>
  <done>ConnectionStore persists connections as JSON with all states, autonomy levels, nicknames, and TTL expiration. Default autonomy is full_manual. Upgrading from full_manual to full_auto requires explicit confirmation (confirmed: true), enforcing the locked user decision at the data layer; confirmation UX deferred to Phase 3 skill integration. Short message limit enforced at 280 chars. Sorting follows state priority then recency. Save/load roundtrip preserves all data. All connection store tests pass.</done>
</task>

</tasks>

<verification>
1. `cd skill && pnpm test` -- all TypeScript tests pass (auth, relay-client, connection-store)
2. `cd skill && pnpm exec tsc --noEmit` -- TypeScript compiles without errors
3. RelayClient no longer uses `?address=` query param
4. ConnectionStore defaults to full_manual autonomy for new connections
5. Connection store JSON roundtrip preserves all fields
</verification>

<success_criteria>
- Auth module signs challenges with Ed25519 via libsodium
- RelayClient performs full auth handshake (challenge -> sign -> verify -> assigned address)
- No ?address= query parameter anywhere in the client code
- assignedAddress property populated after successful auth
- ConnectionStore persists all connection states (active, pending_outbound, pending_inbound, blocked, revoked)
- New connections default to full_manual autonomy (AUTO-02)
- Autonomy levels configurable per connection (AUTO-01), with confirmation gate on full_manual -> full_auto upgrade (confirmation UX deferred to Phase 3)
- Short message limit of 280 chars enforced
- Pending request TTL of 7 days with expiration cleanup
- Local-only nicknames supported
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/02-authentication-and-connection/02-03-SUMMARY.md`
</output>
