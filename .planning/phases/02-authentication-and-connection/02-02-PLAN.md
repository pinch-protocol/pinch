---
phase: 02-authentication-and-connection
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - relay/internal/store/blockstore.go
  - relay/internal/store/blockstore_test.go
  - relay/internal/hub/hub.go
  - relay/internal/hub/client.go
  - relay/internal/hub/hub_test.go
  - relay/cmd/pinchd/main.go
autonomous: true
requirements: [CONN-04]

must_haves:
  truths:
    - "When an agent blocks another, the relay silently drops all messages from the blocked pubkey to the blocking agent"
    - "Block list persists across relay restarts (bbolt-backed)"
    - "Blocking is reversible -- unblocking restores the connection without needing a new connection request"
    - "A blocked agent receives no indication they have been blocked (silent drop)"
  artifacts:
    - path: "relay/internal/store/blockstore.go"
      provides: "bbolt-backed persistent block list with Block/Unblock/IsBlocked"
      exports: ["NewBlockStore", "Block", "Unblock", "IsBlocked", "Close"]
    - path: "relay/internal/hub/hub.go"
      provides: "Message routing with block enforcement"
      contains: "RouteMessage"
  key_links:
    - from: "relay/internal/hub/hub.go"
      to: "relay/internal/store/blockstore.go"
      via: "Hub.RouteMessage checks blockStore.IsBlocked before delivery"
      pattern: "blockStore\\.IsBlocked"
    - from: "relay/cmd/pinchd/main.go"
      to: "relay/internal/store/blockstore.go"
      via: "main opens bbolt DB and passes blockStore to Hub"
      pattern: "store\\.NewBlockStore"
---

<objective>
Implement bbolt-backed block list persistence at the relay and add message routing with block enforcement to the hub, so that blocked agents' messages are silently dropped.

Purpose: Relay-enforced blocking prevents blocked agents from consuming any relay resources for the blocker. Block persistence ensures blocks survive relay restarts.
Output: BlockStore with bbolt, Hub message routing with block checking, updated main.go wiring.
</objective>

<execution_context>
@/Users/riecekeck/.claude/get-shit-done/workflows/execute-plan.md
@/Users/riecekeck/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-authentication-and-connection/02-RESEARCH.md
@.planning/phases/02-authentication-and-connection/02-01-SUMMARY.md
@relay/internal/hub/hub.go
@relay/internal/hub/client.go
@relay/cmd/pinchd/main.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement bbolt-backed block store</name>
  <files>
    relay/internal/store/blockstore.go
    relay/internal/store/blockstore_test.go
  </files>
  <action>
    **Create `relay/internal/store/blockstore.go`:**

    Add bbolt dependency: `cd relay && go get go.etcd.io/bbolt@latest`

    Implement `BlockStore` struct backed by bbolt:

    ```
    type BlockStore struct {
        db *bolt.DB
    }
    ```

    Bucket name: `"blocks"`. Key format: `"blockerAddr:blockedAddr"` -> `"1"`.

    Methods:
    - `NewBlockStore(path string) (*BlockStore, error)` -- Opens bbolt DB at path with 0600 permissions. Creates "blocks" bucket if not exists. Returns error if DB cannot be opened.
    - `Block(blockerAddr, blockedAddr string) error` -- Puts key in blocks bucket. Uses `db.Update` (read-write transaction).
    - `Unblock(blockerAddr, blockedAddr string) error` -- Deletes key from blocks bucket. Uses `db.Update`. Per discretion decision: blocking is reversible. Unblocking restores the connection without needing a new request.
    - `IsBlocked(blockerAddr, senderAddr string) bool` -- Checks if key exists in blocks bucket. Uses `db.View` (read-only transaction, fast and concurrent).
    - `Close() error` -- Closes the bbolt DB.

    **Create `relay/internal/store/blockstore_test.go`:**

    Test cases (use `t.TempDir()` for bbolt DB path):
    - Block adds entry, IsBlocked returns true
    - IsBlocked returns false for non-blocked pairs
    - Unblock removes entry, IsBlocked returns false after unblock
    - Block is directional: A blocks B does not mean B blocks A
    - Persistence: close and reopen DB, block list survives
    - Multiple blocks from same blocker work correctly
  </action>
  <verify>
    <automated>cd /Users/riecekeck/Coding/Pinch && go test ./relay/internal/store/ -v -race</automated>
  </verify>
  <done>BlockStore persists block pairs in bbolt, supports Block/Unblock/IsBlocked with directional semantics, and survives DB close/reopen. All tests pass with -race.</done>
</task>

<task type="auto">
  <name>Task 2: Add message routing to hub with block enforcement</name>
  <files>
    relay/internal/hub/hub.go
    relay/internal/hub/client.go
    relay/internal/hub/hub_test.go
    relay/cmd/pinchd/main.go
  </files>
  <action>
    **Modify `relay/internal/hub/hub.go`:**

    Add a `blockStore` field to Hub (pointer to `store.BlockStore`, can be nil for tests that don't need blocking). Update `NewHub` to accept an optional `*store.BlockStore` parameter.

    Add `RouteMessage(from *Client, envelope []byte) error` method:
    1. Deserialize the envelope bytes as a protobuf `Envelope` to extract `to_address` and `type`
    2. Handle special message types:
       - `MESSAGE_TYPE_BLOCK_NOTIFICATION`: Extract `BlockNotification` payload, call `blockStore.Block(blocker, blocked)` where blocker is the authenticated `from.Address()`. Only the `blocked_address` field matters; `blocker_address` is verified from the authenticated sender. Return nil (no routing needed).
       - `MESSAGE_TYPE_UNBLOCK_NOTIFICATION`: Extract `UnblockNotification` payload, call `blockStore.Unblock(unblocker, unblocked)`. Return nil.
    3. For all other message types: check `blockStore.IsBlocked(toAddress, from.Address())`. If blocked, silently drop (return nil, no error to sender -- per locked decision).
    4. Look up recipient in routing table via `LookupClient(toAddress)`. If not found, silently drop (consistent behavior -- sender cannot distinguish between offline and blocked/rejected).
    5. Send raw envelope bytes to recipient's send channel.

    **Modify `relay/internal/hub/client.go`:**

    Update `ReadPump` to route received messages instead of discarding them. When a message is read from the WebSocket:
    1. Call `c.hub.RouteMessage(c, messageBytes)` instead of discarding
    2. Log routing errors at debug level but don't disconnect the client

    Add a `Send(data []byte)` method on Client that writes to the send channel (non-blocking with a select+default to handle full buffers by dropping the message and logging).

    **Modify `relay/cmd/pinchd/main.go`:**

    1. Create BlockStore at startup: `blockStore, err := store.NewBlockStore(dbPath)` where dbPath comes from env var `PINCH_RELAY_DB` (default "./pinch-relay.db"). Defer `blockStore.Close()`.
    2. Pass blockStore to `hub.NewHub(blockStore)`.

    **Extend `relay/internal/hub/hub_test.go`:**

    Add test cases:
    - RouteMessage delivers message to correct recipient
    - RouteMessage silently drops message when recipient is offline
    - RouteMessage silently drops message when sender is blocked by recipient
    - BlockNotification message type updates block store
    - UnblockNotification restores message delivery
    - Blocked sender receives no error indication
  </action>
  <verify>
    <automated>cd /Users/riecekeck/Coding/Pinch && go test ./relay/internal/hub/ -v -race && go test ./relay/internal/store/ -v -race && go build ./relay/cmd/pinchd/</automated>
  </verify>
  <done>Hub routes messages to recipients by address with block enforcement. BlockNotification and UnblockNotification are handled as relay-side commands. Blocked messages are silently dropped. ReadPump routes messages instead of discarding. Main.go opens bbolt and wires block store into hub. All hub and store tests pass with -race.</done>
</task>

</tasks>

<verification>
1. `go test ./relay/internal/store/ -v -race` -- block store tests pass
2. `go test ./relay/internal/hub/ -v -race` -- hub routing and block enforcement tests pass
3. `go build ./relay/cmd/pinchd/` -- relay compiles with block store and routing
4. Block list survives bbolt close/reopen (tested in store tests)
5. Blocked messages produce no error or indication to the sender
</verification>

<success_criteria>
- bbolt block store persists block pairs with directional semantics
- Blocking is reversible via Unblock (per discretion decision)
- Hub routes messages to correct recipients by to_address
- Block check happens BEFORE message delivery
- BlockNotification/UnblockNotification messages update the relay's block store
- Silent drop for blocked messages -- sender receives no indication
- Silent drop for offline recipients -- indistinguishable from blocked/rejected
- All tests pass with -race flag
</success_criteria>

<output>
After completion, create `.planning/phases/02-authentication-and-connection/02-02-SUMMARY.md`
</output>
