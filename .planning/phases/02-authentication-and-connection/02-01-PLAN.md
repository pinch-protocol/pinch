---
phase: 02-authentication-and-connection
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - proto/pinch/v1/envelope.proto
  - gen/go/pinch/v1/envelope.pb.go
  - gen/ts/pinch/v1/envelope_pb.ts
  - relay/internal/auth/auth.go
  - relay/internal/auth/auth_test.go
  - relay/internal/hub/client.go
  - relay/internal/hub/hub.go
  - relay/cmd/pinchd/main.go
autonomous: true
requirements: [RELY-02]

must_haves:
  truths:
    - "Relay sends a 32-byte nonce challenge after WebSocket upgrade and verifies the agent's Ed25519 signature before registering in routing table"
    - "Agent connects, signs the nonce with its Ed25519 private key, and receives confirmation of its assigned pinch: address"
    - "Unauthenticated clients cannot send or receive messages -- only authenticated clients are registered in the hub"
    - "Auth times out after 10 seconds if the client never responds to the challenge"
  artifacts:
    - path: "proto/pinch/v1/envelope.proto"
      provides: "AuthChallenge, AuthResponse, AuthResult, ConnectionRequest, ConnectionResponse, ConnectionRevoke, BlockNotification message types"
      contains: "message AuthChallenge"
    - path: "gen/go/pinch/v1/envelope.pb.go"
      provides: "Generated Go types for all Phase 2 protobuf messages"
    - path: "gen/ts/pinch/v1/envelope_pb.ts"
      provides: "Generated TypeScript types for all Phase 2 protobuf messages"
    - path: "relay/internal/auth/auth.go"
      provides: "Challenge generation and signature verification"
      exports: ["GenerateChallenge", "VerifyChallenge", "DeriveAddress"]
    - path: "relay/cmd/pinchd/main.go"
      provides: "Rewritten wsHandler with post-upgrade auth handshake"
  key_links:
    - from: "relay/cmd/pinchd/main.go"
      to: "relay/internal/auth/auth.go"
      via: "wsHandler calls GenerateChallenge, VerifyChallenge, DeriveAddress"
      pattern: "auth\\.GenerateChallenge|auth\\.VerifyChallenge|auth\\.DeriveAddress"
    - from: "relay/cmd/pinchd/main.go"
      to: "relay/internal/hub/hub.go"
      via: "hub.Register only called AFTER auth succeeds"
      pattern: "h\\.Register"
---

<objective>
Extend the protobuf schema with all Phase 2 message types (auth, connection, block, revoke) and implement Ed25519 challenge-response authentication on the relay, replacing the insecure `?address=` query parameter flow.

Purpose: Close the impersonation attack vector from Phase 1 where any agent could claim any address. After this plan, every connected agent has cryptographically proven ownership of its `pinch:` address.
Output: Extended proto schema with generated Go+TS code, relay auth module, rewritten wsHandler with challenge-response handshake.
</objective>

<execution_context>
@/Users/riecekeck/.claude/get-shit-done/workflows/execute-plan.md
@/Users/riecekeck/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-authentication-and-connection/02-RESEARCH.md
@.planning/phases/01-foundation-and-crypto-primitives/01-01-SUMMARY.md
@.planning/phases/01-foundation-and-crypto-primitives/01-03-SUMMARY.md
@proto/pinch/v1/envelope.proto
@relay/internal/hub/hub.go
@relay/internal/hub/client.go
@relay/cmd/pinchd/main.go
@relay/internal/identity/identity.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend protobuf schema with Phase 2 message types and regenerate</name>
  <files>
    proto/pinch/v1/envelope.proto
    gen/go/pinch/v1/envelope.pb.go
    gen/ts/pinch/v1/envelope_pb.ts
  </files>
  <action>
    Extend `proto/pinch/v1/envelope.proto` with all Phase 2 message types. Add these new message types:

    1. **AuthChallenge**: `bytes nonce = 1` (32-byte random), `int64 timestamp = 2` (server time for timeout tracking)
    2. **AuthResponse**: `bytes signature = 1` (64-byte Ed25519 sig of nonce), `bytes public_key = 2` (32-byte Ed25519 pubkey)
    3. **AuthResult**: `bool success = 1`, `string error_message = 2` (only on failure), `string assigned_address = 3` (the pinch: address derived from pubkey)
    4. **ConnectionRequest**: `string from_address = 1`, `string to_address = 2`, `string message = 3` (free-text short message, max 280 chars enforced at application level), `bytes sender_public_key = 4`, `int64 expires_at = 5` (Unix timestamp for 7-day TTL)
    5. **ConnectionResponse**: `string from_address = 1`, `string to_address = 2`, `bool accepted = 3`, `bytes responder_public_key = 4` (only populated if accepted)
    6. **ConnectionRevoke**: `string from_address = 1`, `string to_address = 2`
    7. **BlockNotification**: `string blocker_address = 1`, `string blocked_address = 2`
    8. **UnblockNotification**: `string unblocker_address = 1`, `string unblocked_address = 2` (for reversible blocking per discretion decision)

    Add new enum values to MessageType:
    - `MESSAGE_TYPE_AUTH_RESULT = 9`
    - `MESSAGE_TYPE_CONNECTION_REVOKE = 10`
    - `MESSAGE_TYPE_BLOCK_NOTIFICATION = 11`
    - `MESSAGE_TYPE_UNBLOCK_NOTIFICATION = 12`

    Add to Envelope's `oneof payload`:
    - `AuthChallenge auth_challenge = 13`
    - `AuthResponse auth_response = 14`
    - `AuthResult auth_result = 15`
    - `ConnectionRequest connection_request = 16`
    - `ConnectionResponse connection_response = 17`
    - `ConnectionRevoke connection_revoke = 18`
    - `BlockNotification block_notification = 19`
    - `UnblockNotification unblock_notification = 20`

    Then run `buf generate` from project root to regenerate Go and TypeScript code.

    IMPORTANT: Follow established pattern from 01-01-SUMMARY -- `buf.gen.yaml` has `clean: false` to preserve go.mod and package.json in gen/ directories. Verify both generated files compile: `go build ./gen/go/...` and `cd skill && pnpm exec tsc --noEmit`.
  </action>
  <verify>
    <automated>cd /Users/riecekeck/Coding/Pinch && buf generate && go build ./gen/go/... && cd skill && pnpm exec tsc --noEmit</automated>
    <manual>Verify envelope.proto has all 8 new message types and the Envelope oneof has all new payload fields</manual>
  </verify>
  <done>Proto schema has AuthChallenge, AuthResponse, AuthResult, ConnectionRequest, ConnectionResponse, ConnectionRevoke, BlockNotification, UnblockNotification messages. Generated Go and TypeScript code compiles. Envelope oneof includes all new payload variants.</done>
</task>

<task type="auto">
  <name>Task 2: Implement relay auth module and rewrite wsHandler with challenge-response</name>
  <files>
    relay/internal/auth/auth.go
    relay/internal/auth/auth_test.go
    relay/internal/hub/client.go
    relay/cmd/pinchd/main.go
  </files>
  <action>
    **Create `relay/internal/auth/auth.go`:**

    Implement three functions:
    - `GenerateChallenge() ([]byte, error)` -- Generate 32-byte random nonce using `crypto/rand.Read`. MUST use crypto/rand, never math/rand.
    - `VerifyChallenge(pubKey ed25519.PublicKey, nonce, signature []byte) bool` -- Verify Ed25519 signature using `ed25519.Verify`.
    - `DeriveAddress(pubKey ed25519.PublicKey, relayHost string) string` -- Derive `pinch:` address from public key. Use the same address format established in Phase 1 (`relay/internal/identity/identity.go`): `pinch:<base58(pubkey + sha256(pubkey)[0:4])>@<host>`. Import and reuse the existing identity package's `GenerateAddress` function if it exists, or implement the same algorithm.

    **Create `relay/internal/auth/auth_test.go`:**

    Test cases:
    - GenerateChallenge returns 32 bytes, two calls produce different nonces
    - VerifyChallenge succeeds with valid signature, fails with wrong signature, fails with wrong nonce
    - DeriveAddress produces correct pinch: format and matches existing identity package output

    **Modify `relay/internal/hub/client.go`:**

    Add a `PublicKey` field (`ed25519.PublicKey`) to the Client struct so the authenticated public key is available for block checking and connection routing. Update `NewClient` to accept a `pubKey` parameter instead of `address` -- the address is derived from the pubkey during auth, so the caller provides both.

    **Rewrite `relay/cmd/pinchd/main.go` wsHandler:**

    Replace the `?address=` query parameter flow with post-upgrade challenge-response:

    1. Accept WebSocket upgrade (keep InsecureSkipVerify for dev)
    2. Generate 32-byte nonce via `auth.GenerateChallenge()`
    3. Serialize an `AuthChallenge` protobuf Envelope and send it over WebSocket
    4. Set a 10-second read deadline (use `context.WithTimeout`)
    5. Read the client's response -- deserialize as Envelope, expect `AuthResponse` payload
    6. Extract public key and signature from AuthResponse
    7. Verify signature: `auth.VerifyChallenge(pubKey, nonce, signature)`
    8. If verification fails: send `AuthResult(success: false, error_message: "...")`, close WebSocket with code 4001, return
    9. Derive pinch: address from pubkey: `auth.DeriveAddress(pubKey, relayHost)` where relayHost comes from an env var `PINCH_RELAY_HOST` (default "localhost")
    10. Send `AuthResult(success: true, assigned_address: addr)` to client
    11. Create Client with address and pubkey, register with hub, start goroutines

    CRITICAL: Do NOT register the client in the hub until auth succeeds. This prevents the auth race condition described in research pitfall 1.

    For serializing/deserializing protobuf Envelopes on the Go side, use the generated protobuf types from `gen/go/pinch/v1`. Use `proto.Marshal` and `proto.Unmarshal` from `google.golang.org/protobuf/proto`.
  </action>
  <verify>
    <automated>cd /Users/riecekeck/Coding/Pinch && go test ./relay/internal/auth/ -v -race && go build ./relay/cmd/pinchd/</automated>
    <manual>Verify wsHandler no longer accepts ?address= query parameter</manual>
  </verify>
  <done>Relay auth module generates challenges, verifies Ed25519 signatures, and derives addresses. wsHandler performs post-upgrade challenge-response handshake with 10s timeout. Client struct stores authenticated public key. Unauthenticated clients never enter the hub routing table. Auth tests pass with -race.</done>
</task>

</tasks>

<verification>
1. `go test ./relay/internal/auth/ -v -race` -- all auth unit tests pass
2. `go build ./relay/cmd/pinchd/` -- relay binary compiles with new auth flow
3. `buf generate` produces no errors
4. Generated Go code compiles: `go build ./gen/go/...`
5. Generated TypeScript code compiles: `cd skill && pnpm exec tsc --noEmit`
</verification>

<success_criteria>
- Proto schema extended with all 8 new message types and Envelope oneof includes all new payloads
- Relay auth module generates 32-byte nonces from crypto/rand and verifies Ed25519 signatures
- wsHandler performs challenge-response instead of ?address= query param
- Auth timeout of 10 seconds prevents resource exhaustion
- Client struct stores authenticated public key
- No client is registered in hub before auth completes
- All tests pass with -race flag
</success_criteria>

<output>
After completion, create `.planning/phases/02-authentication-and-connection/02-01-SUMMARY.md`
</output>
