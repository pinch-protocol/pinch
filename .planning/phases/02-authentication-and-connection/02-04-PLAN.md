---
phase: 02-authentication-and-connection
plan: 04
type: execute
wave: 3
depends_on: ["02-02", "02-03"]
files_modified:
  - skill/src/connection.ts
  - skill/src/connection.test.ts
  - skill/src/relay-client.ts
  - relay/internal/hub/hub_test.go
  - tests/cross-language/auth_handshake.sh
autonomous: true
requirements: [CONN-01, CONN-02, CONN-03, CONN-06]

must_haves:
  truths:
    - "Agent A sends a connection request to Agent B's pinch: address with a short message; Agent B sees the pending request in their connection store"
    - "Agent B's human approves the request; both agents exchange public keys and the connection is marked active on both sides"
    - "Agent B's human rejects the request; sender receives no feedback (silent rejection indistinguishable from offline)"
    - "Either party can revoke a connection; the other party receives a connection-ended signal and both sides mark it revoked"
    - "Agent can block a connection; relay silently drops all future messages from the blocked pubkey"
    - "Agent can unblock a connection; message delivery resumes without re-requesting"
  artifacts:
    - path: "skill/src/connection.ts"
      provides: "Connection lifecycle manager: request, approve, reject, block, unblock, revoke"
      exports: ["ConnectionManager"]
    - path: "tests/cross-language/auth_handshake.sh"
      provides: "End-to-end integration test: auth, connection request/approve, block, revoke"
  key_links:
    - from: "skill/src/connection.ts"
      to: "skill/src/relay-client.ts"
      via: "ConnectionManager sends protobuf Envelopes via RelayClient for connection requests/responses/revokes/blocks"
      pattern: "relayClient.*send|sendEnvelope"
    - from: "skill/src/connection.ts"
      to: "skill/src/connection-store.ts"
      via: "ConnectionManager reads and writes connection state"
      pattern: "connectionStore\\.(add|update|get|set)"
    - from: "skill/src/connection.ts"
      to: "gen/ts/pinch/v1/envelope_pb.ts"
      via: "Creates ConnectionRequest, ConnectionResponse, ConnectionRevoke, BlockNotification protobuf messages"
      pattern: "ConnectionRequest|ConnectionResponse|ConnectionRevoke|BlockNotification"
---

<objective>
Implement the full connection lifecycle (request, approve, reject, block, unblock, revoke) with the TypeScript ConnectionManager, wire the relay's message routing for connection messages, and validate the entire auth-through-connection flow with cross-language integration tests.

Purpose: This is the culmination of Phase 2 -- agents can authenticate, request connections, approve/reject them, exchange keys, block/unblock, and revoke. Every user decision from CONTEXT.md is honored: silent rejection, revoke-with-notification, block-as-silent-drop, reversible blocking.
Output: ConnectionManager module, RelayClient send capability, end-to-end integration tests.
</objective>

<execution_context>
@/Users/riecekeck/.claude/get-shit-done/workflows/execute-plan.md
@/Users/riecekeck/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-authentication-and-connection/02-RESEARCH.md
@.planning/phases/02-authentication-and-connection/02-CONTEXT.md
@.planning/phases/02-authentication-and-connection/02-01-SUMMARY.md
@.planning/phases/02-authentication-and-connection/02-02-SUMMARY.md
@.planning/phases/02-authentication-and-connection/02-03-SUMMARY.md
@skill/src/relay-client.ts
@skill/src/connection-store.ts
@skill/src/connection.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement ConnectionManager with full connection lifecycle</name>
  <files>
    skill/src/connection.ts
    skill/src/connection.test.ts
    skill/src/relay-client.ts
  </files>
  <action>
    **Add `sendEnvelope` method to `skill/src/relay-client.ts`:**

    Add a public method `sendEnvelope(envelope: Uint8Array): void` that sends binary data over the WebSocket. Also add a typed message handler that deserializes incoming Envelope protobuf messages and dispatches them by type.

    Add `onEnvelope(handler: (envelope: Envelope) => void): void` method that registers a handler for deserialized protobuf Envelopes (replacing or complementing the raw `onMessage` handler). The handler receives parsed Envelope objects so downstream code doesn't need to deal with raw bytes.

    **Create `skill/src/connection.ts`:**

    Implement `ConnectionManager` class that orchestrates connection lifecycle operations. Constructor takes `RelayClient` and `ConnectionStore`.

    Methods:

    1. `async sendRequest(toAddress: string, message: string): Promise<void>`
       - Validate message length <= 280 chars (throw if exceeded)
       - Create `ConnectionRequest` protobuf: from_address = own address (from relayClient.assignedAddress), to_address, message, sender_public_key = own pubkey, expires_at = now + 7 days (604800s)
       - Wrap in Envelope with type MESSAGE_TYPE_CONNECTION_REQUEST
       - Send via relayClient.sendEnvelope
       - Add to connectionStore as pending_outbound with the short message and expiresAt

    2. `async handleIncomingRequest(envelope: Envelope): Promise<void>`
       - Extract ConnectionRequest from envelope payload
       - Add to connectionStore as pending_inbound, storing sender's pubkey and short message
       - This method is called by the envelope handler when a CONNECTION_REQUEST arrives
       - The pending_inbound entry surfaces for human approval (Phase 3 skill integration will present this)

    3. `async approveRequest(peerAddress: string): Promise<void>`
       - Look up connection in store, verify state is pending_inbound
       - Create `ConnectionResponse` protobuf: accepted = true, responder_public_key = own pubkey
       - Wrap in Envelope with type MESSAGE_TYPE_CONNECTION_RESPONSE, send via relay
       - Update connection state to "active", set peerPublicKey from the stored request

    4. `async rejectRequest(peerAddress: string): Promise<void>`
       - Look up connection in store, verify state is pending_inbound
       - Per locked decision: silent rejection. Do NOT send any response to the requester. The sender receives no feedback and cannot infer whether the recipient exists.
       - Update connection state to "revoked" in local store (expired/rejected requests get cleaned up)

    5. `async handleIncomingResponse(envelope: Envelope): Promise<void>`
       - Extract ConnectionResponse from envelope payload
       - If accepted: update connection from pending_outbound to active, store responder's public key
       - If not accepted: this should never happen (silent rejection means no response is sent), but handle gracefully by updating to revoked

    6. `async blockConnection(peerAddress: string): Promise<void>`
       - Update connection state to "blocked" in connection store
       - Send `BlockNotification` to relay (so relay enforces the block server-side)
       - The blocked agent receives no indication (silent drop enforced by relay per Plan 02)

    7. `async unblockConnection(peerAddress: string): Promise<void>`
       - Per discretion decision: blocking is reversible. Unblock restores the connection.
       - Update connection state back to "active" in connection store
       - Send `UnblockNotification` to relay (relay removes the block entry)

    8. `async revokeConnection(peerAddress: string): Promise<void>`
       - Per locked decision: revoking sends a "connection ended" signal to the other party
       - Create `ConnectionRevoke` protobuf and send via relay
       - Update connection state to "revoked" in local store
       - After revoke, either party can send a new connection request to reconnect

    9. `handleIncomingRevoke(envelope: Envelope): void`
       - Extract ConnectionRevoke payload
       - Update connection state to "revoked" in local store
       - The agent now knows the connection was terminated (unlike blocking which is silent)

    10. `setupHandlers(): void`
        - Register envelope handler on RelayClient that dispatches based on MessageType:
          - MESSAGE_TYPE_CONNECTION_REQUEST -> handleIncomingRequest
          - MESSAGE_TYPE_CONNECTION_RESPONSE -> handleIncomingResponse
          - MESSAGE_TYPE_CONNECTION_REVOKE -> handleIncomingRevoke
          - Other types: ignore (will be handled by messaging layer in Phase 3)

    **Create `skill/src/connection.test.ts`:**

    Unit tests (mock RelayClient and ConnectionStore or use in-memory variants):
    - sendRequest creates pending_outbound connection and sends ConnectionRequest envelope
    - sendRequest rejects message > 280 chars
    - handleIncomingRequest creates pending_inbound connection with sender info
    - approveRequest sends ConnectionResponse with own pubkey and marks connection active
    - rejectRequest does NOT send any response (verify no sendEnvelope call) and marks as revoked
    - handleIncomingResponse (accepted) marks connection active and stores responder pubkey
    - blockConnection sends BlockNotification and marks connection blocked
    - unblockConnection sends UnblockNotification and marks connection active
    - revokeConnection sends ConnectionRevoke and marks connection revoked
    - handleIncomingRevoke marks connection revoked
    - Full flow: request -> approve -> active on both sides
    - Full flow: request -> reject -> no feedback to sender
    - Autonomy: new connections from approveRequest default to full_manual
  </action>
  <verify>
    <automated>cd /Users/riecekeck/Coding/Pinch/skill && pnpm test -- --reporter=verbose 2>&1 | head -100</automated>
  </verify>
  <done>ConnectionManager handles complete lifecycle: request, approve (with key exchange), reject (silent), block (relay-enforced), unblock (reversible), revoke (notified). All user decisions from CONTEXT.md honored. Unit tests pass for all flows.</done>
</task>

<task type="auto">
  <name>Task 2: Cross-language integration tests for auth and connection lifecycle</name>
  <files>
    tests/cross-language/auth_handshake.sh
    relay/internal/hub/hub_test.go
  </files>
  <action>
    **Create `tests/cross-language/auth_handshake.sh`:**

    End-to-end integration test script (follows pattern from Phase 1's `run.sh`):

    1. Build the Go relay: `go build -o ./pinchd ./relay/cmd/pinchd/`
    2. Start the relay on a random port (find free port or use a known test port like 18080)
    3. Use TypeScript test scripts (create small .ts files if needed, or use vitest with a specific test file that performs the integration scenario):

    **Scenario 1: Auth Handshake**
    - Generate a keypair in TypeScript
    - Connect to relay -- should complete auth handshake and get assigned address
    - Verify assigned address matches expected `pinch:` format
    - Disconnect

    **Scenario 2: Connection Request + Approve**
    - Two agents (Agent A and Agent B) connect and auth
    - Agent A sends connection request to Agent B with message "Hello from A"
    - Agent B receives the request (verify pending_inbound in B's store)
    - Agent B approves -- Agent A receives ConnectionResponse with B's pubkey
    - Both sides verify connection is active with each other's public keys

    **Scenario 3: Block Enforcement**
    - Agent B blocks Agent A (sends BlockNotification to relay)
    - Agent A sends a message to Agent B
    - Verify Agent B does NOT receive the message (relay silently drops it)
    - Agent B unblocks Agent A
    - Agent A sends another message -- Agent B receives it

    **Scenario 4: Revoke**
    - Agent A revokes connection with Agent B
    - Agent B receives ConnectionRevoke notification
    - Both sides verify connection state is revoked

    Clean up: kill relay process, remove temp files.

    The script should exit 0 on success, non-zero on failure. Use set -euo pipefail.

    **Extend `relay/internal/hub/hub_test.go`:**

    Add Go-level integration tests that exercise the auth handshake and message routing more deeply:
    - Test auth handshake with a real WebSocket connection (use httptest server)
    - Test that auth failure (bad signature) results in connection closure
    - Test that auth timeout (no response within 10s) results in connection closure
    - Test connection request routing from Agent A to Agent B through the hub
    - Test block enforcement: after BlockNotification, messages from blocked agent are dropped
  </action>
  <verify>
    <automated>cd /Users/riecekeck/Coding/Pinch && go test ./relay/internal/hub/ -v -race -run "TestAuth|TestRoute|TestBlock" && bash tests/cross-language/auth_handshake.sh</automated>
  </verify>
  <done>End-to-end integration tests validate: auth handshake assigns correct address, connection request/approve exchanges keys, block enforcement silently drops messages, unblock restores delivery, revoke notifies the other party. Go hub tests cover auth failure/timeout edge cases. Cross-language tests pass.</done>
</task>

</tasks>

<verification>
1. `cd skill && pnpm test` -- all TypeScript tests pass (connection, auth, relay-client, connection-store)
2. `go test ./relay/internal/hub/ -v -race` -- Go hub tests pass including auth and routing
3. `bash tests/cross-language/auth_handshake.sh` -- cross-language integration tests pass
4. Silent rejection: no response sent when request is rejected
5. Block enforcement: blocked messages silently dropped at relay
6. Revoke: other party receives notification
7. Key exchange: both sides have each other's pubkey after approval
</verification>

<success_criteria>
- Connection request carries sender's address + short message + pubkey + TTL (CONN-01)
- Receiving agent sees pending request with sender info (CONN-02)
- On approval, agents exchange public keys (CONN-03)
- Block enforcement at relay: silent drop, no indication to sender (CONN-04 -- verified)
- Revoke sends connection-ended signal, both sides mark revoked (CONN-06)
- Silent rejection: sender receives no feedback, indistinguishable from offline
- Reversible blocking: unblock restores connection
- After revoke, either party can re-request
- New connections default to full_manual (AUTO-02 -- verified end-to-end)
- Cross-language integration tests validate the full flow
</success_criteria>

<output>
After completion, create `.planning/phases/02-authentication-and-connection/02-04-SUMMARY.md`
</output>
