// @generated by protoc-gen-es v2.11.0 with parameter "target=ts"
// @generated from file pinch/v1/envelope.proto (package pinch.v1, syntax proto3)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage } from "@bufbuild/protobuf/codegenv2";
import { enumDesc, fileDesc, messageDesc } from "@bufbuild/protobuf/codegenv2";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file pinch/v1/envelope.proto.
 */
export const file_pinch_v1_envelope: GenFile = /*@__PURE__*/
  fileDesc("ChdwaW5jaC92MS9lbnZlbG9wZS5wcm90bxIIcGluY2gudjEinQcKCEVudmVsb3BlEg8KB3ZlcnNpb24YASABKA0SFAoMZnJvbV9hZGRyZXNzGAIgASgJEhIKCnRvX2FkZHJlc3MYAyABKAkSIwoEdHlwZRgEIAEoDjIVLnBpbmNoLnYxLk1lc3NhZ2VUeXBlEhIKCm1lc3NhZ2VfaWQYBSABKAwSEQoJdGltZXN0YW1wGAYgASgDEi8KCWVuY3J5cHRlZBgKIAEoCzIaLnBpbmNoLnYxLkVuY3J5cHRlZFBheWxvYWRIABIoCgloYW5kc2hha2UYCyABKAsyEy5waW5jaC52MS5IYW5kc2hha2VIABIoCgloZWFydGJlYXQYDCABKAsyEy5waW5jaC52MS5IZWFydGJlYXRIABIxCg5hdXRoX2NoYWxsZW5nZRgNIAEoCzIXLnBpbmNoLnYxLkF1dGhDaGFsbGVuZ2VIABIvCg1hdXRoX3Jlc3BvbnNlGA4gASgLMhYucGluY2gudjEuQXV0aFJlc3BvbnNlSAASKwoLYXV0aF9yZXN1bHQYDyABKAsyFC5waW5jaC52MS5BdXRoUmVzdWx0SAASOQoSY29ubmVjdGlvbl9yZXF1ZXN0GBAgASgLMhsucGluY2gudjEuQ29ubmVjdGlvblJlcXVlc3RIABI7ChNjb25uZWN0aW9uX3Jlc3BvbnNlGBEgASgLMhwucGluY2gudjEuQ29ubmVjdGlvblJlc3BvbnNlSAASNwoRY29ubmVjdGlvbl9yZXZva2UYEiABKAsyGi5waW5jaC52MS5Db25uZWN0aW9uUmV2b2tlSAASOQoSYmxvY2tfbm90aWZpY2F0aW9uGBMgASgLMhsucGluY2gudjEuQmxvY2tOb3RpZmljYXRpb25IABI9ChR1bmJsb2NrX25vdGlmaWNhdGlvbhgUIAEoCzIdLnBpbmNoLnYxLlVuYmxvY2tOb3RpZmljYXRpb25IABI1ChBkZWxpdmVyeV9jb25maXJtGBUgASgLMhkucGluY2gudjEuRGVsaXZlcnlDb25maXJtSAASLQoMcXVldWVfc3RhdHVzGBYgASgLMhUucGluY2gudjEuUXVldWVTdGF0dXNIABIpCgpxdWV1ZV9mdWxsGBcgASgLMhMucGluY2gudjEuUXVldWVGdWxsSAASLQoMcmF0ZV9saW1pdGVkGBggASgLMhUucGluY2gudjEuUmF0ZUxpbWl0ZWRIAEIJCgdwYXlsb2FkIlAKEEVuY3J5cHRlZFBheWxvYWQSDQoFbm9uY2UYASABKAwSEgoKY2lwaGVydGV4dBgCIAEoDBIZChFzZW5kZXJfcHVibGljX2tleRgDIAEoDCJvChBQbGFpbnRleHRQYXlsb2FkEg8KB3ZlcnNpb24YASABKA0SEAoIc2VxdWVuY2UYAiABKAQSEQoJdGltZXN0YW1wGAMgASgDEg8KB2NvbnRlbnQYBCABKAwSFAoMY29udGVudF90eXBlGAUgASgJIkkKCUhhbmRzaGFrZRIPCgd2ZXJzaW9uGAEgASgNEhMKC3NpZ25pbmdfa2V5GAIgASgMEhYKDmVuY3J5cHRpb25fa2V5GAMgASgMIh4KCUhlYXJ0YmVhdBIRCgl0aW1lc3RhbXAYASABKAMicAoNQXV0aENoYWxsZW5nZRIPCgd2ZXJzaW9uGAEgASgNEg0KBW5vbmNlGAIgASgMEhQKDGlzc3VlZF9hdF9tcxgDIAEoAxIVCg1leHBpcmVzX2F0X21zGAQgASgDEhIKCnJlbGF5X2hvc3QYBSABKAkiVQoMQXV0aFJlc3BvbnNlEg8KB3ZlcnNpb24YASABKA0SEgoKcHVibGljX2tleRgCIAEoDBIRCglzaWduYXR1cmUYAyABKAwSDQoFbm9uY2UYBCABKAwiTgoKQXV0aFJlc3VsdBIPCgdzdWNjZXNzGAEgASgIEhUKDWVycm9yX21lc3NhZ2UYAiABKAkSGAoQYXNzaWduZWRfYWRkcmVzcxgDIAEoCSJ9ChFDb25uZWN0aW9uUmVxdWVzdBIUCgxmcm9tX2FkZHJlc3MYASABKAkSEgoKdG9fYWRkcmVzcxgCIAEoCRIPCgdtZXNzYWdlGAMgASgJEhkKEXNlbmRlcl9wdWJsaWNfa2V5GAQgASgMEhIKCmV4cGlyZXNfYXQYBSABKAMibgoSQ29ubmVjdGlvblJlc3BvbnNlEhQKDGZyb21fYWRkcmVzcxgBIAEoCRISCgp0b19hZGRyZXNzGAIgASgJEhAKCGFjY2VwdGVkGAMgASgIEhwKFHJlc3BvbmRlcl9wdWJsaWNfa2V5GAQgASgMIjwKEENvbm5lY3Rpb25SZXZva2USFAoMZnJvbV9hZGRyZXNzGAEgASgJEhIKCnRvX2FkZHJlc3MYAiABKAkiRQoRQmxvY2tOb3RpZmljYXRpb24SFwoPYmxvY2tlcl9hZGRyZXNzGAEgASgJEhcKD2Jsb2NrZWRfYWRkcmVzcxgCIAEoCSJLChNVbmJsb2NrTm90aWZpY2F0aW9uEhkKEXVuYmxvY2tlcl9hZGRyZXNzGAEgASgJEhkKEXVuYmxvY2tlZF9hZGRyZXNzGAIgASgJIm4KD0RlbGl2ZXJ5Q29uZmlybRISCgptZXNzYWdlX2lkGAEgASgMEhEKCXNpZ25hdHVyZRgCIAEoDBIRCgl0aW1lc3RhbXAYAyABKAMSDQoFc3RhdGUYBCABKAkSEgoKd2FzX3N0b3JlZBgFIAEoCCIkCgtRdWV1ZVN0YXR1cxIVCg1wZW5kaW5nX2NvdW50GAEgASgFIjYKCVF1ZXVlRnVsbBIZChFyZWNpcGllbnRfYWRkcmVzcxgBIAEoCRIOCgZyZWFzb24YAiABKAkiNQoLUmF0ZUxpbWl0ZWQSFgoOcmV0cnlfYWZ0ZXJfbXMYASABKAMSDgoGcmVhc29uGAIgASgJKpUECgtNZXNzYWdlVHlwZRIcChhNRVNTQUdFX1RZUEVfVU5TUEVDSUZJRUQQABIaChZNRVNTQUdFX1RZUEVfSEFORFNIQUtFEAESHwobTUVTU0FHRV9UWVBFX0FVVEhfQ0hBTExFTkdFEAISHgoaTUVTU0FHRV9UWVBFX0FVVEhfUkVTUE9OU0UQAxIYChRNRVNTQUdFX1RZUEVfTUVTU0FHRRAEEiEKHU1FU1NBR0VfVFlQRV9ERUxJVkVSWV9DT05GSVJNEAUSIwofTUVTU0FHRV9UWVBFX0NPTk5FQ1RJT05fUkVRVUVTVBAGEiQKIE1FU1NBR0VfVFlQRV9DT05ORUNUSU9OX1JFU1BPTlNFEAcSGgoWTUVTU0FHRV9UWVBFX0hFQVJUQkVBVBAIEhwKGE1FU1NBR0VfVFlQRV9BVVRIX1JFU1VMVBAJEiIKHk1FU1NBR0VfVFlQRV9DT05ORUNUSU9OX1JFVk9LRRAKEiMKH01FU1NBR0VfVFlQRV9CTE9DS19OT1RJRklDQVRJT04QCxIlCiFNRVNTQUdFX1RZUEVfVU5CTE9DS19OT1RJRklDQVRJT04QDBIdChlNRVNTQUdFX1RZUEVfUVVFVUVfU1RBVFVTEA0SGwoXTUVTU0FHRV9UWVBFX1FVRVVFX0ZVTEwQDhIdChlNRVNTQUdFX1RZUEVfUkFURV9MSU1JVEVEEA9ClwEKDGNvbS5waW5jaC52MUINRW52ZWxvcGVQcm90b1ABWjdnaXRodWIuY29tL3BpbmNoLXByb3RvY29sL3BpbmNoL2dlbi9nby9waW5jaC92MTtwaW5jaHYxogIDUFhYqgIIUGluY2guVjHKAghQaW5jaFxWMeICFFBpbmNoXFYxXEdQQk1ldGFkYXRh6gIJUGluY2g6OlYxYgZwcm90bzM");

/**
 * Envelope is the outer wire message. The relay can read this for routing
 * but never sees the encrypted inner payload.
 *
 * @generated from message pinch.v1.Envelope
 */
export type Envelope = Message<"pinch.v1.Envelope"> & {
  /**
   * @generated from field: uint32 version = 1;
   */
  version: number;

  /**
   * @generated from field: string from_address = 2;
   */
  fromAddress: string;

  /**
   * @generated from field: string to_address = 3;
   */
  toAddress: string;

  /**
   * @generated from field: pinch.v1.MessageType type = 4;
   */
  type: MessageType;

  /**
   * @generated from field: bytes message_id = 5;
   */
  messageId: Uint8Array;

  /**
   * @generated from field: int64 timestamp = 6;
   */
  timestamp: bigint;

  /**
   * @generated from oneof pinch.v1.Envelope.payload
   */
  payload: {
    /**
     * @generated from field: pinch.v1.EncryptedPayload encrypted = 10;
     */
    value: EncryptedPayload;
    case: "encrypted";
  } | {
    /**
     * @generated from field: pinch.v1.Handshake handshake = 11;
     */
    value: Handshake;
    case: "handshake";
  } | {
    /**
     * @generated from field: pinch.v1.Heartbeat heartbeat = 12;
     */
    value: Heartbeat;
    case: "heartbeat";
  } | {
    /**
     * @generated from field: pinch.v1.AuthChallenge auth_challenge = 13;
     */
    value: AuthChallenge;
    case: "authChallenge";
  } | {
    /**
     * @generated from field: pinch.v1.AuthResponse auth_response = 14;
     */
    value: AuthResponse;
    case: "authResponse";
  } | {
    /**
     * @generated from field: pinch.v1.AuthResult auth_result = 15;
     */
    value: AuthResult;
    case: "authResult";
  } | {
    /**
     * @generated from field: pinch.v1.ConnectionRequest connection_request = 16;
     */
    value: ConnectionRequest;
    case: "connectionRequest";
  } | {
    /**
     * @generated from field: pinch.v1.ConnectionResponse connection_response = 17;
     */
    value: ConnectionResponse;
    case: "connectionResponse";
  } | {
    /**
     * @generated from field: pinch.v1.ConnectionRevoke connection_revoke = 18;
     */
    value: ConnectionRevoke;
    case: "connectionRevoke";
  } | {
    /**
     * @generated from field: pinch.v1.BlockNotification block_notification = 19;
     */
    value: BlockNotification;
    case: "blockNotification";
  } | {
    /**
     * @generated from field: pinch.v1.UnblockNotification unblock_notification = 20;
     */
    value: UnblockNotification;
    case: "unblockNotification";
  } | {
    /**
     * @generated from field: pinch.v1.DeliveryConfirm delivery_confirm = 21;
     */
    value: DeliveryConfirm;
    case: "deliveryConfirm";
  } | {
    /**
     * @generated from field: pinch.v1.QueueStatus queue_status = 22;
     */
    value: QueueStatus;
    case: "queueStatus";
  } | {
    /**
     * @generated from field: pinch.v1.QueueFull queue_full = 23;
     */
    value: QueueFull;
    case: "queueFull";
  } | {
    /**
     * @generated from field: pinch.v1.RateLimited rate_limited = 24;
     */
    value: RateLimited;
    case: "rateLimited";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message pinch.v1.Envelope.
 * Use `create(EnvelopeSchema)` to create a new message.
 */
export const EnvelopeSchema: GenMessage<Envelope> = /*@__PURE__*/
  messageDesc(file_pinch_v1_envelope, 0);

/**
 * EncryptedPayload is an opaque encrypted blob. The relay cannot read this.
 *
 * @generated from message pinch.v1.EncryptedPayload
 */
export type EncryptedPayload = Message<"pinch.v1.EncryptedPayload"> & {
  /**
   * @generated from field: bytes nonce = 1;
   */
  nonce: Uint8Array;

  /**
   * @generated from field: bytes ciphertext = 2;
   */
  ciphertext: Uint8Array;

  /**
   * @generated from field: bytes sender_public_key = 3;
   */
  senderPublicKey: Uint8Array;
};

/**
 * Describes the message pinch.v1.EncryptedPayload.
 * Use `create(EncryptedPayloadSchema)` to create a new message.
 */
export const EncryptedPayloadSchema: GenMessage<EncryptedPayload> = /*@__PURE__*/
  messageDesc(file_pinch_v1_envelope, 1);

/**
 * PlaintextPayload exists only in decrypted form at the client.
 * Sequence and timestamp live inside the encryption boundary for
 * replay protection (the relay cannot tamper with these fields).
 *
 * @generated from message pinch.v1.PlaintextPayload
 */
export type PlaintextPayload = Message<"pinch.v1.PlaintextPayload"> & {
  /**
   * @generated from field: uint32 version = 1;
   */
  version: number;

  /**
   * @generated from field: uint64 sequence = 2;
   */
  sequence: bigint;

  /**
   * @generated from field: int64 timestamp = 3;
   */
  timestamp: bigint;

  /**
   * @generated from field: bytes content = 4;
   */
  content: Uint8Array;

  /**
   * @generated from field: string content_type = 5;
   */
  contentType: string;
};

/**
 * Describes the message pinch.v1.PlaintextPayload.
 * Use `create(PlaintextPayloadSchema)` to create a new message.
 */
export const PlaintextPayloadSchema: GenMessage<PlaintextPayload> = /*@__PURE__*/
  messageDesc(file_pinch_v1_envelope, 2);

/**
 * Handshake is sent during initial connection setup.
 *
 * @generated from message pinch.v1.Handshake
 */
export type Handshake = Message<"pinch.v1.Handshake"> & {
  /**
   * @generated from field: uint32 version = 1;
   */
  version: number;

  /**
   * @generated from field: bytes signing_key = 2;
   */
  signingKey: Uint8Array;

  /**
   * @generated from field: bytes encryption_key = 3;
   */
  encryptionKey: Uint8Array;
};

/**
 * Describes the message pinch.v1.Handshake.
 * Use `create(HandshakeSchema)` to create a new message.
 */
export const HandshakeSchema: GenMessage<Handshake> = /*@__PURE__*/
  messageDesc(file_pinch_v1_envelope, 3);

/**
 * Heartbeat is a keep-alive message.
 *
 * @generated from message pinch.v1.Heartbeat
 */
export type Heartbeat = Message<"pinch.v1.Heartbeat"> & {
  /**
   * @generated from field: int64 timestamp = 1;
   */
  timestamp: bigint;
};

/**
 * Describes the message pinch.v1.Heartbeat.
 * Use `create(HeartbeatSchema)` to create a new message.
 */
export const HeartbeatSchema: GenMessage<Heartbeat> = /*@__PURE__*/
  messageDesc(file_pinch_v1_envelope, 4);

/**
 * AuthChallenge is sent by the relay on connect. The agent signs
 * pinch-auth-v1\0<relay_host>\0<nonce> and returns AuthResponse.
 *
 * @generated from message pinch.v1.AuthChallenge
 */
export type AuthChallenge = Message<"pinch.v1.AuthChallenge"> & {
  /**
   * @generated from field: uint32 version = 1;
   */
  version: number;

  /**
   * @generated from field: bytes nonce = 2;
   */
  nonce: Uint8Array;

  /**
   * @generated from field: int64 issued_at_ms = 3;
   */
  issuedAtMs: bigint;

  /**
   * @generated from field: int64 expires_at_ms = 4;
   */
  expiresAtMs: bigint;

  /**
   * @generated from field: string relay_host = 5;
   */
  relayHost: string;
};

/**
 * Describes the message pinch.v1.AuthChallenge.
 * Use `create(AuthChallengeSchema)` to create a new message.
 */
export const AuthChallengeSchema: GenMessage<AuthChallenge> = /*@__PURE__*/
  messageDesc(file_pinch_v1_envelope, 5);

/**
 * AuthResponse proves possession of the Ed25519 private key for the
 * presented public key.
 *
 * @generated from message pinch.v1.AuthResponse
 */
export type AuthResponse = Message<"pinch.v1.AuthResponse"> & {
  /**
   * @generated from field: uint32 version = 1;
   */
  version: number;

  /**
   * @generated from field: bytes public_key = 2;
   */
  publicKey: Uint8Array;

  /**
   * @generated from field: bytes signature = 3;
   */
  signature: Uint8Array;

  /**
   * @generated from field: bytes nonce = 4;
   */
  nonce: Uint8Array;
};

/**
 * Describes the message pinch.v1.AuthResponse.
 * Use `create(AuthResponseSchema)` to create a new message.
 */
export const AuthResponseSchema: GenMessage<AuthResponse> = /*@__PURE__*/
  messageDesc(file_pinch_v1_envelope, 6);

/**
 * AuthResult is sent by the relay after verifying the AuthResponse.
 *
 * @generated from message pinch.v1.AuthResult
 */
export type AuthResult = Message<"pinch.v1.AuthResult"> & {
  /**
   * @generated from field: bool success = 1;
   */
  success: boolean;

  /**
   * only populated on failure
   *
   * @generated from field: string error_message = 2;
   */
  errorMessage: string;

  /**
   * the pinch: address derived from pubkey
   *
   * @generated from field: string assigned_address = 3;
   */
  assignedAddress: string;
};

/**
 * Describes the message pinch.v1.AuthResult.
 * Use `create(AuthResultSchema)` to create a new message.
 */
export const AuthResultSchema: GenMessage<AuthResult> = /*@__PURE__*/
  messageDesc(file_pinch_v1_envelope, 7);

/**
 * ConnectionRequest is sent by an agent to request a connection with another agent.
 *
 * @generated from message pinch.v1.ConnectionRequest
 */
export type ConnectionRequest = Message<"pinch.v1.ConnectionRequest"> & {
  /**
   * @generated from field: string from_address = 1;
   */
  fromAddress: string;

  /**
   * @generated from field: string to_address = 2;
   */
  toAddress: string;

  /**
   * free-text short message, max 280 chars enforced at application level
   *
   * @generated from field: string message = 3;
   */
  message: string;

  /**
   * @generated from field: bytes sender_public_key = 4;
   */
  senderPublicKey: Uint8Array;

  /**
   * Unix timestamp for 7-day TTL
   *
   * @generated from field: int64 expires_at = 5;
   */
  expiresAt: bigint;
};

/**
 * Describes the message pinch.v1.ConnectionRequest.
 * Use `create(ConnectionRequestSchema)` to create a new message.
 */
export const ConnectionRequestSchema: GenMessage<ConnectionRequest> = /*@__PURE__*/
  messageDesc(file_pinch_v1_envelope, 8);

/**
 * ConnectionResponse is the recipient's response to a ConnectionRequest.
 *
 * @generated from message pinch.v1.ConnectionResponse
 */
export type ConnectionResponse = Message<"pinch.v1.ConnectionResponse"> & {
  /**
   * @generated from field: string from_address = 1;
   */
  fromAddress: string;

  /**
   * @generated from field: string to_address = 2;
   */
  toAddress: string;

  /**
   * @generated from field: bool accepted = 3;
   */
  accepted: boolean;

  /**
   * only populated if accepted
   *
   * @generated from field: bytes responder_public_key = 4;
   */
  responderPublicKey: Uint8Array;
};

/**
 * Describes the message pinch.v1.ConnectionResponse.
 * Use `create(ConnectionResponseSchema)` to create a new message.
 */
export const ConnectionResponseSchema: GenMessage<ConnectionResponse> = /*@__PURE__*/
  messageDesc(file_pinch_v1_envelope, 9);

/**
 * ConnectionRevoke severs a connection between two agents without blocking.
 *
 * @generated from message pinch.v1.ConnectionRevoke
 */
export type ConnectionRevoke = Message<"pinch.v1.ConnectionRevoke"> & {
  /**
   * @generated from field: string from_address = 1;
   */
  fromAddress: string;

  /**
   * @generated from field: string to_address = 2;
   */
  toAddress: string;
};

/**
 * Describes the message pinch.v1.ConnectionRevoke.
 * Use `create(ConnectionRevokeSchema)` to create a new message.
 */
export const ConnectionRevokeSchema: GenMessage<ConnectionRevoke> = /*@__PURE__*/
  messageDesc(file_pinch_v1_envelope, 10);

/**
 * BlockNotification informs the relay that an agent has blocked another.
 *
 * @generated from message pinch.v1.BlockNotification
 */
export type BlockNotification = Message<"pinch.v1.BlockNotification"> & {
  /**
   * @generated from field: string blocker_address = 1;
   */
  blockerAddress: string;

  /**
   * @generated from field: string blocked_address = 2;
   */
  blockedAddress: string;
};

/**
 * Describes the message pinch.v1.BlockNotification.
 * Use `create(BlockNotificationSchema)` to create a new message.
 */
export const BlockNotificationSchema: GenMessage<BlockNotification> = /*@__PURE__*/
  messageDesc(file_pinch_v1_envelope, 11);

/**
 * UnblockNotification informs the relay that an agent has unblocked another.
 *
 * @generated from message pinch.v1.UnblockNotification
 */
export type UnblockNotification = Message<"pinch.v1.UnblockNotification"> & {
  /**
   * @generated from field: string unblocker_address = 1;
   */
  unblockerAddress: string;

  /**
   * @generated from field: string unblocked_address = 2;
   */
  unblockedAddress: string;
};

/**
 * Describes the message pinch.v1.UnblockNotification.
 * Use `create(UnblockNotificationSchema)` to create a new message.
 */
export const UnblockNotificationSchema: GenMessage<UnblockNotification> = /*@__PURE__*/
  messageDesc(file_pinch_v1_envelope, 12);

/**
 * DeliveryConfirm is an E2E signed delivery receipt sent by the recipient
 * back to the sender to confirm message delivery.
 *
 * @generated from message pinch.v1.DeliveryConfirm
 */
export type DeliveryConfirm = Message<"pinch.v1.DeliveryConfirm"> & {
  /**
   * ID of the message being confirmed
   *
   * @generated from field: bytes message_id = 1;
   */
  messageId: Uint8Array;

  /**
   * Ed25519 detached signature of (message_id || timestamp)
   *
   * @generated from field: bytes signature = 2;
   */
  signature: Uint8Array;

  /**
   * confirmation timestamp
   *
   * @generated from field: int64 timestamp = 3;
   */
  timestamp: bigint;

  /**
   * delivery state (e.g., "delivered", "read_by_agent", "escalated_to_human")
   *
   * @generated from field: string state = 4;
   */
  state: string;

  /**
   * true if the message was queued (store-and-forward) and delivered later
   *
   * @generated from field: bool was_stored = 5;
   */
  wasStored: boolean;
};

/**
 * Describes the message pinch.v1.DeliveryConfirm.
 * Use `create(DeliveryConfirmSchema)` to create a new message.
 */
export const DeliveryConfirmSchema: GenMessage<DeliveryConfirm> = /*@__PURE__*/
  messageDesc(file_pinch_v1_envelope, 13);

/**
 * QueueStatus is sent by the relay to inform the agent of pending
 * queued messages before starting a flush.
 *
 * @generated from message pinch.v1.QueueStatus
 */
export type QueueStatus = Message<"pinch.v1.QueueStatus"> & {
  /**
   * @generated from field: int32 pending_count = 1;
   */
  pendingCount: number;
};

/**
 * Describes the message pinch.v1.QueueStatus.
 * Use `create(QueueStatusSchema)` to create a new message.
 */
export const QueueStatusSchema: GenMessage<QueueStatus> = /*@__PURE__*/
  messageDesc(file_pinch_v1_envelope, 14);

/**
 * QueueFull is sent to the sender when the recipient's message queue
 * has reached its capacity and cannot accept more messages.
 *
 * @generated from message pinch.v1.QueueFull
 */
export type QueueFull = Message<"pinch.v1.QueueFull"> & {
  /**
   * @generated from field: string recipient_address = 1;
   */
  recipientAddress: string;

  /**
   * @generated from field: string reason = 2;
   */
  reason: string;
};

/**
 * Describes the message pinch.v1.QueueFull.
 * Use `create(QueueFullSchema)` to create a new message.
 */
export const QueueFullSchema: GenMessage<QueueFull> = /*@__PURE__*/
  messageDesc(file_pinch_v1_envelope, 15);

/**
 * RateLimited is sent to the sender when their messages exceed the
 * per-connection rate limit. Contains retry-after information.
 *
 * @generated from message pinch.v1.RateLimited
 */
export type RateLimited = Message<"pinch.v1.RateLimited"> & {
  /**
   * milliseconds until sender can retry
   *
   * @generated from field: int64 retry_after_ms = 1;
   */
  retryAfterMs: bigint;

  /**
   * human-readable explanation
   *
   * @generated from field: string reason = 2;
   */
  reason: string;
};

/**
 * Describes the message pinch.v1.RateLimited.
 * Use `create(RateLimitedSchema)` to create a new message.
 */
export const RateLimitedSchema: GenMessage<RateLimited> = /*@__PURE__*/
  messageDesc(file_pinch_v1_envelope, 16);

/**
 * MessageType enumerates all wire message types.
 *
 * @generated from enum pinch.v1.MessageType
 */
export enum MessageType {
  /**
   * @generated from enum value: MESSAGE_TYPE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: MESSAGE_TYPE_HANDSHAKE = 1;
   */
  HANDSHAKE = 1,

  /**
   * @generated from enum value: MESSAGE_TYPE_AUTH_CHALLENGE = 2;
   */
  AUTH_CHALLENGE = 2,

  /**
   * @generated from enum value: MESSAGE_TYPE_AUTH_RESPONSE = 3;
   */
  AUTH_RESPONSE = 3,

  /**
   * @generated from enum value: MESSAGE_TYPE_MESSAGE = 4;
   */
  MESSAGE = 4,

  /**
   * @generated from enum value: MESSAGE_TYPE_DELIVERY_CONFIRM = 5;
   */
  DELIVERY_CONFIRM = 5,

  /**
   * @generated from enum value: MESSAGE_TYPE_CONNECTION_REQUEST = 6;
   */
  CONNECTION_REQUEST = 6,

  /**
   * @generated from enum value: MESSAGE_TYPE_CONNECTION_RESPONSE = 7;
   */
  CONNECTION_RESPONSE = 7,

  /**
   * @generated from enum value: MESSAGE_TYPE_HEARTBEAT = 8;
   */
  HEARTBEAT = 8,

  /**
   * @generated from enum value: MESSAGE_TYPE_AUTH_RESULT = 9;
   */
  AUTH_RESULT = 9,

  /**
   * @generated from enum value: MESSAGE_TYPE_CONNECTION_REVOKE = 10;
   */
  CONNECTION_REVOKE = 10,

  /**
   * @generated from enum value: MESSAGE_TYPE_BLOCK_NOTIFICATION = 11;
   */
  BLOCK_NOTIFICATION = 11,

  /**
   * @generated from enum value: MESSAGE_TYPE_UNBLOCK_NOTIFICATION = 12;
   */
  UNBLOCK_NOTIFICATION = 12,

  /**
   * @generated from enum value: MESSAGE_TYPE_QUEUE_STATUS = 13;
   */
  QUEUE_STATUS = 13,

  /**
   * @generated from enum value: MESSAGE_TYPE_QUEUE_FULL = 14;
   */
  QUEUE_FULL = 14,

  /**
   * @generated from enum value: MESSAGE_TYPE_RATE_LIMITED = 15;
   */
  RATE_LIMITED = 15,
}

/**
 * Describes the enum pinch.v1.MessageType.
 */
export const MessageTypeSchema: GenEnum<MessageType> = /*@__PURE__*/
  enumDesc(file_pinch_v1_envelope, 0);

